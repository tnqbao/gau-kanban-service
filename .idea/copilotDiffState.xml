<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Gau Kanban Service&#10;&#10;## Mô tả dự án&#10;&#10;Gau Kanban Service là một RESTful API service được xây dựng bằng Go để quản lý bảng Kanban. Dự án cung cấp các tính năng hoàn chỉnh để tạo và quản lý boards, columns, tickets, assignments và labels cho việc quản lý dự án theo phương pháp Kanban.&#10;&#10;## Tính năng chính&#10;&#10;### ️ Quản lý Columns&#10;- Tạo, sửa, xóa columns&#10;- Sắp xếp lại vị trí columns&#10;- Quản lý thứ tự hiển thị&#10;&#10;###  Quản lý Tickets&#10;- Tạo tickets với ticket number tự động (TASK-XXXX)&#10;- CRUD operations cho tickets&#10;- Di chuyển tickets giữa các columns&#10;- Drag &amp; drop với position management thông minh&#10;- Tự động sắp xếp vị trí khi tạo ticket mới (luôn ở cuối column)&#10;- Hỗ trợ due date và priority&#10;&#10;###  Quản lý Assignments&#10;- Gán người dùng vào tickets&#10;- Quản lý thông tin assignees (user_id, user_full_name)&#10;- Xóa assignments theo user hoặc ticket&#10;- Hiển thị assignees trong thông tin tickets&#10;&#10;### ️ Quản lý Labels&#10;- Tạo và quản lý labels với màu sắc&#10;- Gán labels vào tickets&#10;- Quản lý many-to-many relationship&#10;&#10;###  Quản lý Comments&#10;- Thêm comments vào tickets&#10;- Quản lý discussions cho từng ticket&#10;&#10;## Công nghệ sử dụng&#10;&#10;- **Backend**: Go (Golang) với Gin framework&#10;- **Database**: PostgreSQL với GORM ORM&#10;- **Migration**: golang-migrate&#10;- **Container**: Docker &amp; Docker Compose&#10;- **Architecture**: Clean Architecture với Repository pattern&#10;&#10;## Cấu trúc dự án&#10;&#10;```&#10;gau-kanban-service/&#10;├── main.go                 # Entry point&#10;├── Dockerfile             # Docker configuration&#10;├── entrypoint.sh          # Docker entrypoint script&#10;├── config/                # Configuration management&#10;├── controller/            # HTTP handlers&#10;├── entity/               # Database models&#10;├── repository/           # Data access layer&#10;├── routes/               # API routes definition&#10;├── migrations/           # Database migrations&#10;├── infra/                # Infrastructure setup&#10;└── utils/                # Utility functions&#10;```&#10;&#10;## API Endpoints&#10;&#10;### Column Management&#10;```&#10;POST   /api/v2/kanban/columns              # Tạo column mới&#10;GET    /api/v2/kanban/columns              # Lấy danh sách columns&#10;PUT    /api/v2/kanban/columns/:id          # Cập nhật column&#10;DELETE /api/v2/kanban/columns/:id          # Xóa column&#10;PATCH  /api/v2/kanban/columns/:id/position # Cập nhật vị trí column&#10;```&#10;&#10;### Ticket Management&#10;```&#10;POST   /api/v2/kanban/tickets                    # Tạo ticket mới&#10;GET    /api/v2/kanban/tickets                    # Lấy danh sách tickets&#10;GET    /api/v2/kanban/tickets/:id                # Lấy thông tin ticket&#10;PUT    /api/v2/kanban/tickets/:id                # Cập nhật ticket&#10;DELETE /api/v2/kanban/tickets/:id                # Xóa ticket&#10;PATCH  /api/v2/kanban/tickets/move               # Di chuyển ticket&#10;PATCH  /api/v2/kanban/tickets/move-with-position # Di chuyển ticket với vị trí cụ thể&#10;PATCH  /api/v2/kanban/tickets/:id/position       # Cập nhật vị trí ticket&#10;```&#10;&#10;### Assignment Management&#10;```&#10;POST   /api/v2/kanban/assignments                     # Tạo assignment&#10;PUT    /api/v2/kanban/assignments/:id                 # Cập nhật assignment&#10;DELETE /api/v2/kanban/assignments/:id                 # Xóa assignment&#10;DELETE /api/v2/kanban/users/:user_id/assignments      # Xóa tất cả assignments của user&#10;GET    /api/v2/kanban/tickets/:ticket_id/assignments  # Lấy assignments của ticket&#10;```&#10;&#10;### Kanban Board&#10;```&#10;GET    /api/v2/kanban/board       # Lấy toàn bộ kanban board&#10;GET    /api/v2/kanban/tag-colors  # Lấy màu sắc tags&#10;```&#10;&#10;## Cài đặt và chạy&#10;&#10;### Yêu cầu hệ thống&#10;- Go 1.23+&#10;- PostgreSQL 12+&#10;- Docker &amp; Docker Compose (optional)&#10;&#10;### Chạy với Docker&#10;```bash&#10;# Clone repository&#10;git clone &lt;repository-url&gt;&#10;cd gau-kanban-service&#10;&#10;# Chạy với Docker Compose&#10;docker-compose up -d&#10;&#10;# Service sẽ chạy trên port 8080&#10;```&#10;&#10;### Chạy development&#10;```bash&#10;# Cài đặt dependencies&#10;go mod tidy&#10;&#10;# Setup database (PostgreSQL)&#10;# Tạo database: gau_kanban&#10;&#10;# Chạy migrations&#10;migrate -path migrations -database &quot;postgres://username:password@localhost/gau_kanban?sslmode=disable&quot; up&#10;&#10;# Chạy service&#10;go run main.go&#10;```&#10;&#10;### Environment Variables&#10;```bash&#10;DB_HOST=localhost&#10;DB_PORT=5432&#10;DB_USER=postgres&#10;DB_PASSWORD=password&#10;DB_NAME=gau_kanban&#10;DB_SSLMODE=disable&#10;PORT=8080&#10;```&#10;&#10;## Tính năng nổi bật&#10;&#10;###  Smart Position Management&#10;- Tự động sắp xếp vị trí tickets khi drag &amp; drop&#10;- Hỗ trợ di chuyển giữa các columns với transaction safety&#10;- Tickets mới luôn được đặt ở cuối column&#10;&#10;###  Auto Ticket Numbering&#10;- Tự động tạo ticket number theo format TASK-XXXX&#10;- Unique và sequential numbering&#10;&#10;###  Rich Data Response&#10;- API responses bao gồm đầy đủ thông tin assignees&#10;- Nested data cho kanban board view&#10;- Optimized queries cho performance&#10;&#10;### ️ Data Integrity&#10;- Database constraints và foreign keys&#10;- Transaction handling cho complex operations&#10;- Error handling và validation&#10;&#10;## Database Schema&#10;&#10;### Core Tables&#10;- `columns`: Quản lý các cột kanban&#10;- `tickets`: Quản lý các tickets/tasks&#10;- `task_assignments`: Gán người dùng vào tickets&#10;- `labels`: Quản lý labels/tags&#10;- `ticket_labels`: Many-to-many relationship&#10;- `ticket_comments`: Comments cho tickets&#10;&#10;### Key Features&#10;- UUID primary keys&#10;- Timestamps tracking&#10;- Position-based ordering&#10;- Cascading deletes&#10;&#10;## Migration Management&#10;&#10;```bash&#10;# Tạo migration mới&#10;migrate create -ext sql -dir migrations -seq migration_name&#10;&#10;# Chạy migrations&#10;migrate -path migrations -database $DATABASE_URL up&#10;&#10;# Rollback migration&#10;migrate -path migrations -database $DATABASE_URL down 1&#10;```&#10;&#10;## API Examples&#10;&#10;### Tạo ticket mới&#10;```bash&#10;curl -X POST http://localhost:8080/api/v2/kanban/tickets \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;column_id&quot;: &quot;uuid-column-id&quot;,&#10;    &quot;title&quot;: &quot;New task&quot;,&#10;    &quot;description&quot;: &quot;Task description&quot;,&#10;    &quot;priority&quot;: &quot;HIGH&quot;&#10;  }'&#10;```&#10;&#10;### Di chuyển ticket với position&#10;```bash&#10;curl -X PATCH http://localhost:8080/api/v2/kanban/tickets/move-with-position \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;ticket_id&quot;: &quot;uuid-ticket-id&quot;,&#10;    &quot;column_id&quot;: &quot;uuid-column-id&quot;,&#10;    &quot;position&quot;: 2&#10;  }'&#10;```&#10;&#10;### Tạo assignment&#10;```bash&#10;curl -X POST http://localhost:8080/api/v2/kanban/assignments \&#10;  -H &quot;Content-Type: application/json&quot; \&#10;  -d '{&#10;    &quot;ticket_id&quot;: &quot;uuid-ticket-id&quot;,&#10;    &quot;user_id&quot;: &quot;uuid-user-id&quot;,&#10;    &quot;user_full_name&quot;: &quot;Nguyễn Văn A&quot;&#10;  }'&#10;```&#10;&#10;## Contributing&#10;&#10;1. Fork the repository&#10;2. Create feature branch (`git checkout -b feature/amazing-feature`)&#10;3. Commit changes (`git commit -m 'Add amazing feature'`)&#10;4. Push to branch (`git push origin feature/amazing-feature`)&#10;5. Open a Pull Request&#10;&#10;## License&#10;&#10;This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.&#10;&#10;## Support&#10;&#10;Nếu có vấn đề hoặc câu hỏi, vui lòng tạo issue trong repository này.&#10;&#10;---&#10;&#10;**Phát triển bởi Gau Team** &#10;&#10;" />
              <option name="updatedContent" value="# Gau Kanban Service&#10;&#10;## Mô tả dự án&#10;&#10;Gau Kanban Service là một RESTful API service được xây dựng bằng Go để quản lý bảng Kanban. Dự án cung cấp các tính năng hoàn chỉnh để tạo và quản lý boards, columns, tickets, assignments, checklists và labels cho việc quản lý dự án theo phương pháp Kanban.&#10;&#10;## Tính năng chính&#10;&#10;### ️ Quản lý Columns&#10;- Tạo, sửa, xóa columns&#10;- Sắp xếp lại vị trí columns&#10;- Quản lý thứ tự hiển thị&#10;&#10;###  Quản lý Tickets&#10;- Tạo tickets với ticket number tự động (TASK-XXXX format)&#10;- CRUD operations cho tickets&#10;- Di chuyển tickets giữa các columns với position management thông minh&#10;- Drag &amp; drop hỗ trợ di chuyển vào vị trí bất kỳ trong column&#10;- Tự động sắp xếp vị trí khi tạo ticket mới (luôn ở cuối column)&#10;- Hỗ trợ due date và priority&#10;- Tích hợp assignments và checklists trong ticket operations&#10;&#10;###  Quản lý Assignments&#10;- Gán người dùng vào tickets (không cần tạo bảng user riêng)&#10;- Quản lý thông tin assignees (user_id, user_full_name)&#10;- CRUD operations: tạo, sửa, xóa assignments&#10;- Xóa tất cả assignments theo user ID&#10;- Hiển thị assignees trong thông tin tickets&#10;&#10;### ✅ Quản lý Checklists&#10;- Tạo checklist items cho tickets&#10;- Đánh dấu hoàn thành/chưa hoàn thành&#10;- Sắp xếp thứ tự checklist items&#10;- Tích hợp trong ticket create/update operations&#10;- CRUD operations riêng biệt cho từng checklist item&#10;&#10;### ️ Quản lý Labels&#10;- Tạo và quản lý labels với màu sắc&#10;- Gán labels vào tickets&#10;- Quản lý many-to-many relationship&#10;&#10;###  Quản lý Comments&#10;- Thêm comments vào tickets&#10;- Quản lý discussions cho từng ticket&#10;&#10;## Công nghệ sử dụng&#10;&#10;- **Backend**: Go (Golang) với Gin framework&#10;- **Database**: PostgreSQL với GORM ORM&#10;- **Migration**: golang-migrate&#10;- **Container**: Docker &amp; Docker Compose&#10;- **Architecture**: Clean Architecture với Repository pattern&#10;&#10;## Cấu trúc dự án&#10;&#10;```&#10;gau-kanban-service/&#10;├── main.go                 # Entry point&#10;├── Dockerfile             # Docker configuration&#10;├── entrypoint.sh          # Docker entrypoint script&#10;├── config/                # Configuration management&#10;├── controller/            # HTTP controllers&#10;│   ├── ticket.go         # Ticket operations&#10;│   ├── assignment.go     # Assignment operations  &#10;│   ├── checklist.go      # Checklist operations&#10;│   ├── column.go         # Column operations&#10;│   └── dto.go            # Data Transfer Objects&#10;├── entity/               # Domain entities&#10;│   ├── ticket.go         # Ticket entity&#10;│   ├── task_assignment.go # Assignment entity&#10;│   ├── checklist.go      # Checklist entity&#10;│   └── column.go         # Column entity&#10;├── repository/           # Data access layer&#10;│   ├── ticket.go         # Ticket repository&#10;│   ├── task_assignment.go # Assignment repository&#10;│   ├── checklist.go      # Checklist repository&#10;│   └── interfaces.go     # Repository interfaces&#10;├── routes/               # Route definitions&#10;├── migrations/           # Database migrations&#10;├── utils/                # Utility functions&#10;└── deploy/               # Kubernetes deployment configs&#10;```&#10;&#10;## API Endpoints&#10;&#10;### Tickets&#10;- `POST /api/tickets` - Tạo ticket mới (có thể kèm assignments và checklists)&#10;- `GET /api/tickets` - Lấy danh sách tickets (kèm assignees và checklists)&#10;- `GET /api/tickets/:id` - Lấy ticket theo ID (kèm assignees và checklists)&#10;- `PUT /api/tickets/:id` - Cập nhật ticket (có thể cập nhật assignments và checklists)&#10;- `DELETE /api/tickets/:id` - Xóa ticket&#10;- `PUT /api/tickets/:id/position` - Cập nhật vị trí ticket trong column&#10;- `PUT /api/tickets/move` - Di chuyển ticket sang column khác&#10;- `PUT /api/tickets/move-with-position` - Di chuyển ticket với vị trí cụ thể&#10;&#10;### Assignments&#10;- `POST /api/assignments` - Tạo assignment mới&#10;- `GET /api/assignments/ticket/:ticket_id` - Lấy assignments của ticket&#10;- `PUT /api/assignments/:id` - Cập nhật assignment&#10;- `DELETE /api/assignments/:id` - Xóa assignment&#10;- `DELETE /api/assignments/user/:user_id` - Xóa tất cả assignments của user&#10;&#10;### Checklists&#10;- `POST /api/checklists` - Tạo checklist item mới&#10;- `GET /api/checklists/ticket/:ticketId` - Lấy checklists của ticket&#10;- `PUT /api/checklists/:id` - Cập nhật checklist item&#10;- `PUT /api/checklists/:id/position` - Cập nhật vị trí checklist item&#10;- `DELETE /api/checklists/:id` - Xóa checklist item&#10;&#10;### Columns&#10;- `POST /api/columns` - Tạo column mới&#10;- `GET /api/columns` - Lấy danh sách columns&#10;- `GET /api/columns/:id` - Lấy column theo ID&#10;- `PUT /api/columns/:id` - Cập nhật column&#10;- `DELETE /api/columns/:id` - Xóa column&#10;- `PUT /api/columns/:id/position` - Cập nhật vị trí column&#10;&#10;### Kanban Board&#10;- `GET /api/kanban/board` - Lấy toàn bộ kanban board với columns và tickets&#10;&#10;## Tính năng đặc biệt&#10;&#10;### Smart Position Management&#10;- Hệ thống tự động quản lý vị trí tickets khi drag &amp; drop&#10;- Hỗ trợ di chuyển ticket vào vị trí bất kỳ trong column (ví dụ: từ vị trí 2 lên vị trí 4 trong column có 10 tickets)&#10;- Tự động điều chỉnh position của các tickets khác&#10;- Xử lý di chuyển giữa các columns khác nhau&#10;&#10;### Automatic Ticket Numbering&#10;- Ticket number tự động theo format TASK-XXXX (ví dụ: TASK-0001, TASK-0002)&#10;- Sử dụng PostgreSQL sequence để đảm bảo tính duy nhất&#10;- Không bị trùng lặp khi tạo đồng thời&#10;&#10;### Integrated Operations&#10;- Tạo/cập nhật ticket có thể kèm theo assignments và checklists&#10;- Tự động xóa assignments và checklists khi xóa ticket&#10;- API riêng biệt cho từng component để tối ưu performance&#10;&#10;## Cài đặt và chạy&#10;&#10;### Prerequisites&#10;- Go 1.21+&#10;- PostgreSQL 13+&#10;- Docker &amp; Docker Compose (optional)&#10;&#10;### Local Development&#10;```bash&#10;# Clone repository&#10;git clone &lt;repository-url&gt;&#10;cd gau-kanban-service&#10;&#10;# Install dependencies&#10;go mod tidy&#10;&#10;# Setup database&#10;createdb kanban_db&#10;&#10;# Run migrations&#10;migrate -path migrations -database &quot;postgres://username:password@localhost/kanban_db?sslmode=disable&quot; up&#10;&#10;# Run the application&#10;go run main.go&#10;```&#10;&#10;### Docker Development&#10;```bash&#10;# Build and run with Docker Compose&#10;docker-compose up --build&#10;&#10;# Run migrations&#10;docker-compose exec app migrate -path migrations -database $DATABASE_URL up&#10;```&#10;&#10;### Kubernetes Deployment&#10;```bash&#10;# Deploy to staging&#10;cd deploy/k8s/staging&#10;./apply.sh&#10;&#10;# Deploy to production&#10;cd deploy/k8s/production&#10;./apply.sh&#10;```&#10;&#10;## Database Schema&#10;&#10;### Tickets Table&#10;- id (UUID, Primary Key)&#10;- ticket_no (Text, Unique) - Format: TASK-XXXX&#10;- column_id (UUID, Foreign Key)&#10;- title (Text)&#10;- description (Text)&#10;- due_date (Date)&#10;- priority (Text)&#10;- position (Integer) - Vị trí trong column&#10;- created_at, updated_at (Timestamp)&#10;&#10;### Task Assignments Table&#10;- id (UUID, Primary Key)&#10;- ticket_id (UUID, Foreign Key)&#10;- user_id (UUID)&#10;- user_full_name (Text)&#10;- assigned_at (Timestamp)&#10;&#10;### Checklists Table&#10;- id (UUID, Primary Key)&#10;- ticket_id (UUID, Foreign Key)&#10;- title (Text)&#10;- completed (Boolean)&#10;- position (Integer) - Vị trí trong ticket&#10;- created_at, updated_at (Timestamp)&#10;&#10;## Environment Variables&#10;&#10;```bash&#10;DATABASE_URL=postgres://username:password@localhost/kanban_db?sslmode=disable&#10;PORT=8080&#10;GIN_MODE=release # for production&#10;```&#10;&#10;## Contributing&#10;&#10;1. Fork repository&#10;2. Tạo feature branch (`git checkout -b feature/amazing-feature`)&#10;3. Commit changes (`git commit -m 'Add amazing feature'`)&#10;4. Push to branch (`git push origin feature/amazing-feature`)&#10;5. Tạo Pull Request&#10;&#10;## License&#10;&#10;This project is licensed under the MIT License - see the LICENSE file for details." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/controller/assignment.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/controller/assignment.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/utils&quot;&#10;)&#10;&#10;// CreateAssignment tạo assignment mới cho ticket&#10;func (ctrl *Controller) CreateAssignment(c *gin.Context) {&#10;&#9;var req CreateAssignmentRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Kiểm tra ticket có tồn tại không&#10;&#9;_, err := ctrl.Repository.GetTicketByID(req.TicketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Ticket not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;assignment := &amp;entity.TaskAssignment{&#10;&#9;&#9;TicketID:     req.TicketID,&#10;&#9;&#9;UserID:       req.UserID,&#10;&#9;&#9;UserFullName: req.UserFullName,&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.CreateAssignment(assignment); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Assignment created successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    assignment,&#10;&#9;})&#10;}&#10;&#10;// UpdateAssignment cập nhật thông tin assignment&#10;func (ctrl *Controller) UpdateAssignment(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var req UpdateAssignmentRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;assignment, err := ctrl.Repository.GetAssignmentByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Assignment not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if req.UserFullName != &quot;&quot; {&#10;&#9;&#9;assignment.UserFullName = req.UserFullName&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.UpdateAssignment(assignment); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Assignment updated successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    assignment,&#10;&#9;})&#10;}&#10;&#10;// DeleteAssignment xóa assignment&#10;func (ctrl *Controller) DeleteAssignment(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#10;&#9;if err := ctrl.Repository.DeleteAssignment(id); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Assignment deleted successfully&quot;,&#10;&#9;})&#10;}&#10;&#10;// GetTicketAssignments lấy danh sách assignments của ticket&#10;func (ctrl *Controller) GetTicketAssignments(c *gin.Context) {&#10;&#9;ticketID := c.Param(&quot;ticket_id&quot;)&#10;&#10;&#9;assignments, err := ctrl.Repository.GetAssignmentsByTicketID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;data&quot;: assignments,&#10;&#9;})&#10;}&#10;&#10;// DeleteAssignmentsByUserID xóa tất cả assignments của một user&#10;func (ctrl *Controller) DeleteAssignmentsByUserID(c *gin.Context) {&#10;&#9;userID := c.Param(&quot;user_id&quot;)&#10;&#10;&#9;if err := ctrl.Repository.DeleteAssignmentsByUserID(userID); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;All assignments for user deleted successfully&quot;,&#10;&#9;})&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/utils&quot;&#10;)&#10;&#10;// CreateAssignment tạo assignment mới cho ticket&#10;func (ctrl *Controller) CreateAssignment(c *gin.Context) {&#10;&#9;var req CreateAssignmentRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Kiểm tra ticket có tồn tại không&#10;&#9;_, err := ctrl.Repository.GetTicketByID(req.TicketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Ticket not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;assignment := &amp;entity.TaskAssignment{&#10;&#9;&#9;TicketID:     req.TicketID,&#10;&#9;&#9;UserID:       req.UserID,&#10;&#9;&#9;UserFullName: req.UserFullName,&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.CreateAssignment(assignment); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Assignment created successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    assignment,&#10;&#9;})&#10;}&#10;&#10;// UpdateAssignment cập nhật thông tin assignment&#10;func (ctrl *Controller) UpdateAssignment(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var req UpdateAssignmentRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;assignment, err := ctrl.Repository.GetAssignmentByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Assignment not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if req.UserFullName != &quot;&quot; {&#10;&#9;&#9;assignment.UserFullName = req.UserFullName&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.UpdateAssignment(assignment); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Assignment updated successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    assignment,&#10;&#9;})&#10;}&#10;&#10;// DeleteAssignment xóa assignment&#10;func (ctrl *Controller) DeleteAssignment(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#10;&#9;if err := ctrl.Repository.DeleteAssignment(id); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Assignment deleted successfully&quot;,&#10;&#9;})&#10;}&#10;&#10;// GetTicketAssignments lấy danh sách assignments của ticket&#10;func (ctrl *Controller) GetTicketAssignments(c *gin.Context) {&#10;&#9;ticketID := c.Param(&quot;ticket_id&quot;)&#10;&#10;&#9;assignments, err := ctrl.Repository.GetAssignmentsByTicketID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;data&quot;: assignments,&#10;&#9;})&#10;}&#10;&#10;// DeleteAssignmentsByUserID xóa tất cả assignments của một user&#10;func (ctrl *Controller) DeleteAssignmentsByUserID(c *gin.Context) {&#10;&#9;userID := c.Param(&quot;user_id&quot;)&#10;&#9;if userID == &quot;&quot; {&#10;&#9;&#9;utils.JSON400(c, &quot;User ID is required&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.DeleteAssignmentsByUserID(userID); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;All assignments for user deleted successfully&quot;,&#10;&#9;})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/controller/checklist.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/controller/checklist.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/utils&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;// CreateChecklist tạo checklist mới cho ticket&#10;func (ctrl *Controller) CreateChecklist(ctx *gin.Context) {&#10;&#9;var req CreateChecklistRequest&#10;&#9;if err := ctx.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusBadRequest, &quot;Invalid request body&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Lấy vị trí tiếp theo cho checklist trong ticket&#10;&#9;maxPosition, err := ctrl.Repository.GetMaxChecklistPosition(req.TicketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusInternalServerError, &quot;Failed to get max position&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;checklist := &amp;entity.Checklist{&#10;&#9;&#9;TicketID:  req.TicketID,&#10;&#9;&#9;Title:     req.Title,&#10;&#9;&#9;Completed: false,&#10;&#9;&#9;Position:  maxPosition + 1,&#10;&#9;&#9;CreatedAt: time.Now().Format(time.RFC3339),&#10;&#9;&#9;UpdatedAt: time.Now().Format(time.RFC3339),&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.CreateChecklist(checklist); err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusInternalServerError, &quot;Failed to create checklist&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;response := ChecklistDTO{&#10;&#9;&#9;ID:        checklist.ID,&#10;&#9;&#9;TicketID:  checklist.TicketID,&#10;&#9;&#9;Title:     checklist.Title,&#10;&#9;&#9;Completed: checklist.Completed,&#10;&#9;&#9;Position:  checklist.Position,&#10;&#9;&#9;CreatedAt: checklist.CreatedAt,&#10;&#9;&#9;UpdatedAt: checklist.UpdatedAt,&#10;&#9;}&#10;&#10;&#9;utils.SendSuccessResponse(ctx, http.StatusCreated, &quot;Checklist created successfully&quot;, response)&#10;}&#10;&#10;// GetChecklistsByTicketID lấy tất cả checklist của một ticket&#10;func (ctrl *Controller) GetChecklistsByTicketID(ctx *gin.Context) {&#10;&#9;ticketID := ctx.Param(&quot;ticketId&quot;)&#10;&#9;if ticketID == &quot;&quot; {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusBadRequest, &quot;Ticket ID is required&quot;, &quot;&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;checklists, err := ctrl.Repository.GetChecklistsByTicketID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusInternalServerError, &quot;Failed to get checklists&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var response []ChecklistDTO&#10;&#9;for _, checklist := range checklists {&#10;&#9;&#9;response = append(response, ChecklistDTO{&#10;&#9;&#9;&#9;ID:        checklist.ID,&#10;&#9;&#9;&#9;TicketID:  checklist.TicketID,&#10;&#9;&#9;&#9;Title:     checklist.Title,&#10;&#9;&#9;&#9;Completed: checklist.Completed,&#10;&#9;&#9;&#9;Position:  checklist.Position,&#10;&#9;&#9;&#9;CreatedAt: checklist.CreatedAt,&#10;&#9;&#9;&#9;UpdatedAt: checklist.UpdatedAt,&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;utils.SendSuccessResponse(ctx, http.StatusOK, &quot;Checklists retrieved successfully&quot;, response)&#10;}&#10;&#10;// UpdateChecklist cập nhật checklist&#10;func (ctrl *Controller) UpdateChecklist(ctx *gin.Context) {&#10;&#9;checklistID := ctx.Param(&quot;id&quot;)&#10;&#9;if checklistID == &quot;&quot; {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusBadRequest, &quot;Checklist ID is required&quot;, &quot;&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var req UpdateChecklistRequest&#10;&#9;if err := ctx.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusBadRequest, &quot;Invalid request body&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;checklist, err := ctrl.Repository.GetChecklistByID(checklistID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusNotFound, &quot;Checklist not found&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Cập nhật các field nếu có trong request&#10;&#9;if req.Title != nil {&#10;&#9;&#9;checklist.Title = *req.Title&#10;&#9;}&#10;&#9;if req.Completed != nil {&#10;&#9;&#9;checklist.Completed = *req.Completed&#10;&#9;}&#10;&#9;if req.Position != nil {&#10;&#9;&#9;checklist.Position = *req.Position&#10;&#9;}&#10;&#10;&#9;checklist.UpdatedAt = time.Now().Format(time.RFC3339)&#10;&#10;&#9;if err := ctrl.Repository.UpdateChecklist(checklist); err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusInternalServerError, &quot;Failed to update checklist&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;response := ChecklistDTO{&#10;&#9;&#9;ID:        checklist.ID,&#10;&#9;&#9;TicketID:  checklist.TicketID,&#10;&#9;&#9;Title:     checklist.Title,&#10;&#9;&#9;Completed: checklist.Completed,&#10;&#9;&#9;Position:  checklist.Position,&#10;&#9;&#9;CreatedAt: checklist.CreatedAt,&#10;&#9;&#9;UpdatedAt: checklist.UpdatedAt,&#10;&#9;}&#10;&#10;&#9;utils.SendSuccessResponse(ctx, http.StatusOK, &quot;Checklist updated successfully&quot;, response)&#10;}&#10;&#10;// UpdateChecklistPosition cập nhật vị trí checklist&#10;func (ctrl *Controller) UpdateChecklistPosition(ctx *gin.Context) {&#10;&#9;checklistID := ctx.Param(&quot;id&quot;)&#10;&#9;if checklistID == &quot;&quot; {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusBadRequest, &quot;Checklist ID is required&quot;, &quot;&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var req UpdateChecklistPositionRequest&#10;&#9;if err := ctx.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusBadRequest, &quot;Invalid request body&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.UpdateChecklistPosition(checklistID, req.Position); err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusInternalServerError, &quot;Failed to update checklist position&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.SendSuccessResponse(ctx, http.StatusOK, &quot;Checklist position updated successfully&quot;, nil)&#10;}&#10;&#10;// DeleteChecklist xóa checklist&#10;func (ctrl *Controller) DeleteChecklist(ctx *gin.Context) {&#10;&#9;checklistID := ctx.Param(&quot;id&quot;)&#10;&#9;if checklistID == &quot;&quot; {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusBadRequest, &quot;Checklist ID is required&quot;, &quot;&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.DeleteChecklist(checklistID); err != nil {&#10;&#9;&#9;utils.SendErrorResponse(ctx, http.StatusInternalServerError, &quot;Failed to delete checklist&quot;, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.SendSuccessResponse(ctx, http.StatusOK, &quot;Checklist deleted successfully&quot;, nil)&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/utils&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;// CreateChecklist tạo checklist mới cho ticket&#10;func (ctrl *Controller) CreateChecklist(ctx *gin.Context) {&#10;&#9;var req CreateChecklistRequest&#10;&#9;if err := ctx.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(ctx, &quot;Invalid request body&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Lấy vị trí tiếp theo cho checklist trong ticket&#10;&#9;maxPosition, err := ctrl.Repository.GetMaxChecklistPosition(req.TicketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(ctx, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;checklist := &amp;entity.Checklist{&#10;&#9;&#9;TicketID:  req.TicketID,&#10;&#9;&#9;Title:     req.Title,&#10;&#9;&#9;Completed: false,&#10;&#9;&#9;Position:  maxPosition + 1,&#10;&#9;&#9;CreatedAt: time.Now().Format(time.RFC3339),&#10;&#9;&#9;UpdatedAt: time.Now().Format(time.RFC3339),&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.CreateChecklist(checklist); err != nil {&#10;&#9;&#9;utils.JSON500(ctx, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;response := ChecklistDTO{&#10;&#9;&#9;ID:        checklist.ID,&#10;&#9;&#9;TicketID:  checklist.TicketID,&#10;&#9;&#9;Title:     checklist.Title,&#10;&#9;&#9;Completed: checklist.Completed,&#10;&#9;&#9;Position:  checklist.Position,&#10;&#9;&#9;CreatedAt: checklist.CreatedAt,&#10;&#9;&#9;UpdatedAt: checklist.UpdatedAt,&#10;&#9;}&#10;&#10;&#9;utils.JSON200(ctx, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Checklist created successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    response,&#10;&#9;})&#10;}&#10;&#10;// GetChecklistsByTicketID lấy tất cả checklist của một ticket&#10;func (ctrl *Controller) GetChecklistsByTicketID(ctx *gin.Context) {&#10;&#9;ticketID := ctx.Param(&quot;ticketId&quot;)&#10;&#9;if ticketID == &quot;&quot; {&#10;&#9;&#9;utils.JSON400(ctx, &quot;Ticket ID is required&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;checklists, err := ctrl.Repository.GetChecklistsByTicketID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(ctx, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var response []ChecklistDTO&#10;&#9;for _, checklist := range checklists {&#10;&#9;&#9;response = append(response, ChecklistDTO{&#10;&#9;&#9;&#9;ID:        checklist.ID,&#10;&#9;&#9;&#9;TicketID:  checklist.TicketID,&#10;&#9;&#9;&#9;Title:     checklist.Title,&#10;&#9;&#9;&#9;Completed: checklist.Completed,&#10;&#9;&#9;&#9;Position:  checklist.Position,&#10;&#9;&#9;&#9;CreatedAt: checklist.CreatedAt,&#10;&#9;&#9;&#9;UpdatedAt: checklist.UpdatedAt,&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;utils.JSON200(ctx, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Checklists retrieved successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    response,&#10;&#9;})&#10;}&#10;&#10;// UpdateChecklist cập nhật checklist&#10;func (ctrl *Controller) UpdateChecklist(ctx *gin.Context) {&#10;&#9;checklistID := ctx.Param(&quot;id&quot;)&#10;&#9;if checklistID == &quot;&quot; {&#10;&#9;&#9;utils.JSON400(ctx, &quot;Checklist ID is required&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var req UpdateChecklistRequest&#10;&#9;if err := ctx.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(ctx, &quot;Invalid request body&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;checklist, err := ctrl.Repository.GetChecklistByID(checklistID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(ctx, &quot;Checklist not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Cập nhật các field nếu có trong request&#10;&#9;if req.Title != nil {&#10;&#9;&#9;checklist.Title = *req.Title&#10;&#9;}&#10;&#9;if req.Completed != nil {&#10;&#9;&#9;checklist.Completed = *req.Completed&#10;&#9;}&#10;&#9;if req.Position != nil {&#10;&#9;&#9;checklist.Position = *req.Position&#10;&#9;}&#10;&#10;&#9;checklist.UpdatedAt = time.Now().Format(time.RFC3339)&#10;&#10;&#9;if err := ctrl.Repository.UpdateChecklist(checklist); err != nil {&#10;&#9;&#9;utils.JSON500(ctx, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;response := ChecklistDTO{&#10;&#9;&#9;ID:        checklist.ID,&#10;&#9;&#9;TicketID:  checklist.TicketID,&#10;&#9;&#9;Title:     checklist.Title,&#10;&#9;&#9;Completed: checklist.Completed,&#10;&#9;&#9;Position:  checklist.Position,&#10;&#9;&#9;CreatedAt: checklist.CreatedAt,&#10;&#9;&#9;UpdatedAt: checklist.UpdatedAt,&#10;&#9;}&#10;&#10;&#9;utils.JSON200(ctx, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Checklist updated successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    response,&#10;&#9;})&#10;}&#10;&#10;// UpdateChecklistPosition cập nhật vị trí checklist&#10;func (ctrl *Controller) UpdateChecklistPosition(ctx *gin.Context) {&#10;&#9;checklistID := ctx.Param(&quot;id&quot;)&#10;&#9;if checklistID == &quot;&quot; {&#10;&#9;&#9;utils.JSON400(ctx, &quot;Checklist ID is required&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var req UpdateChecklistPositionRequest&#10;&#9;if err := ctx.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(ctx, &quot;Invalid request body&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.UpdateChecklistPosition(checklistID, req.Position); err != nil {&#10;&#9;&#9;utils.JSON500(ctx, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(ctx, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Checklist position updated successfully&quot;,&#10;&#9;})&#10;}&#10;&#10;// DeleteChecklist xóa checklist&#10;func (ctrl *Controller) DeleteChecklist(ctx *gin.Context) {&#10;&#9;checklistID := ctx.Param(&quot;id&quot;)&#10;&#9;if checklistID == &quot;&quot; {&#10;&#9;&#9;utils.JSON400(ctx, &quot;Checklist ID is required&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.DeleteChecklist(checklistID); err != nil {&#10;&#9;&#9;utils.JSON500(ctx, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(ctx, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Checklist deleted successfully&quot;,&#10;&#9;})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/controller/dto.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/controller/dto.go" />
              <option name="originalContent" value="package controller&#10;&#10;// Checklist DTOs&#10;// Request/Response structures&#10;type KanbanColumnResponse struct {&#10;&#9;ID      string                 `json:&quot;id&quot;`&#10;&#9;Title   string                 `json:&quot;title&quot;`&#10;&#9;Order   int                    `json:&quot;order&quot;`&#10;&#9;Tickets []KanbanTicketResponse `json:&quot;tickets&quot;`&#10;}&#10;&#10;type KanbanTicketResponse struct {&#10;&#9;ID          string   `json:&quot;id&quot;`&#10;&#9;Title       string   `json:&quot;title&quot;`&#10;&#9;Description string   `json:&quot;description&quot;`&#10;&#9;TicketNo    string   `json:&quot;ticketNo&quot;`&#10;&#9;Tags        []string `json:&quot;tags&quot;`&#10;&#9;Assignees   []string `json:&quot;assignees&quot;`&#10;&#9;Completed   bool     `json:&quot;completed&quot;`&#10;&#9;DueDate     string   `json:&quot;due_date,omitempty&quot;`&#10;&#9;Priority    string   `json:&quot;priority,omitempty&quot;`&#10;}&#10;&#10;type CreateColumnRequest struct {&#10;&#9;Name     string `json:&quot;name&quot; binding:&quot;required&quot;`&#10;&#9;Position int    `json:&quot;position&quot;`&#10;}&#10;&#10;type UpdateColumnRequest struct {&#10;&#9;Name     string `json:&quot;name&quot;`&#10;&#9;Position *int   `json:&quot;position&quot;`&#10;}&#10;&#10;type UpdateColumnPositionRequest struct {&#10;&#9;Position int `json:&quot;position&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type UpdateTicketPositionRequest struct {&#10;&#9;Position int `json:&quot;position&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type CreateAssignmentRequest struct {&#10;&#9;TicketID     string `json:&quot;ticket_id&quot; binding:&quot;required&quot;`&#10;&#9;UserID       string `json:&quot;user_id&quot; binding:&quot;required&quot;`&#10;&#9;UserFullName string `json:&quot;user_full_name&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type UpdateAssignmentRequest struct {&#10;&#9;UserFullName string `json:&quot;user_full_name&quot;`&#10;}&#10;&#10;type ChecklistDTO struct {&#10;&#9;ID        string `json:&quot;id&quot;`&#10;&#9;TicketID  string `json:&quot;ticket_id&quot;`&#10;&#9;Title     string `json:&quot;title&quot;`&#10;&#9;Completed bool   `json:&quot;completed&quot;`&#10;&#9;Position  int    `json:&quot;position&quot;`&#10;&#9;CreatedAt string `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt string `json:&quot;updated_at&quot;`&#10;}&#10;&#10;type CreateChecklistRequest struct {&#10;&#9;TicketID string `json:&quot;ticket_id&quot; validate:&quot;required&quot;`&#10;&#9;Title    string `json:&quot;title&quot; validate:&quot;required&quot;`&#10;}&#10;&#10;type UpdateChecklistRequest struct {&#10;&#9;Title     *string `json:&quot;title,omitempty&quot;`&#10;&#9;Completed *bool   `json:&quot;completed,omitempty&quot;`&#10;&#9;Position  *int    `json:&quot;position,omitempty&quot;`&#10;}&#10;&#10;type UpdateChecklistPositionRequest struct {&#10;&#9;Position int `json:&quot;position&quot; validate:&quot;required&quot;`&#10;}&#10;&#10;// Ticket DTOs with Checklist support&#10;type CreateTicketRequest struct {&#10;&#9;ColumnID    string                   `json:&quot;column_id&quot; validate:&quot;required&quot;`&#10;&#9;Title       string                   `json:&quot;title&quot; validate:&quot;required&quot;`&#10;&#9;Description string                   `json:&quot;description&quot;`&#10;&#9;DueDate     string                   `json:&quot;due_date&quot;`&#10;&#9;Priority    string                   `json:&quot;priority&quot;`&#10;&#9;Checklists  []CreateChecklistRequest `json:&quot;checklists,omitempty&quot;`&#10;}&#10;&#10;type UpdateTicketRequest struct {&#10;&#9;Title       *string                  `json:&quot;title,omitempty&quot;`&#10;&#9;Description *string                  `json:&quot;description,omitempty&quot;`&#10;&#9;DueDate     *string                  `json:&quot;due_date,omitempty&quot;`&#10;&#9;Priority    *string                  `json:&quot;priority,omitempty&quot;`&#10;&#9;Checklists  []UpdateChecklistRequest `json:&quot;checklists,omitempty&quot;`&#10;}&#10;&#10;type TicketWithChecklistsDTO struct {&#10;&#9;ID          string         `json:&quot;id&quot;`&#10;&#9;TicketNo    string         `json:&quot;ticket_no&quot;`&#10;&#9;ColumnID    string         `json:&quot;column_id&quot;`&#10;&#9;Title       string         `json:&quot;title&quot;`&#10;&#9;Description string         `json:&quot;description&quot;`&#10;&#9;DueDate     string         `json:&quot;due_date&quot;`&#10;&#9;Priority    string         `json:&quot;priority&quot;`&#10;&#9;Position    int            `json:&quot;position&quot;`&#10;&#9;Checklists  []ChecklistDTO `json:&quot;checklists&quot;`&#10;&#9;CreatedAt   string         `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   string         `json:&quot;updated_at&quot;`&#10;}&#10;&#10;// Existing DTOs&#10;type MoveTicketRequest struct {&#10;&#9;TicketID string `json:&quot;ticket_id&quot; validate:&quot;required&quot;`&#10;&#9;ColumnID string `json:&quot;column_id&quot; validate:&quot;required&quot;`&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#10;&#10;// Ticket DTOs&#10;type CreateTicketRequest struct {&#10;&#9;ColumnID    string                     `json:&quot;column_id&quot; binding:&quot;required&quot;`&#10;&#9;Title       string                     `json:&quot;title&quot; binding:&quot;required&quot;`&#10;&#9;Description string                     `json:&quot;description&quot;`&#10;&#9;DueDate     string                     `json:&quot;due_date&quot;`&#10;&#9;Priority    string                     `json:&quot;priority&quot;`&#10;&#9;Assignments []CreateAssignmentInTicket `json:&quot;assignments&quot;`&#10;&#9;Checklists  []CreateChecklistInTicket  `json:&quot;checklists&quot;`&#10;}&#10;&#10;type UpdateTicketRequest struct {&#10;&#9;Title       *string                    `json:&quot;title&quot;`&#10;&#9;Description *string                    `json:&quot;description&quot;`&#10;&#9;DueDate     *string                    `json:&quot;due_date&quot;`&#10;&#9;Priority    *string                    `json:&quot;priority&quot;`&#10;&#9;Assignments []CreateAssignmentInTicket `json:&quot;assignments&quot;`&#10;&#9;Checklists  []CreateChecklistInTicket  `json:&quot;checklists&quot;`&#10;}&#10;&#10;type CreateAssignmentInTicket struct {&#10;&#9;UserID       string `json:&quot;user_id&quot; binding:&quot;required&quot;`&#10;&#9;UserFullName string `json:&quot;user_full_name&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type CreateChecklistInTicket struct {&#10;&#9;Title     string `json:&quot;title&quot; binding:&quot;required&quot;`&#10;&#9;Completed bool   `json:&quot;completed&quot;`&#10;}&#10;&#10;type UpdateTicketPositionRequest struct {&#10;&#9;ColumnID string `json:&quot;column_id&quot; binding:&quot;required&quot;`&#10;&#9;Position int    `json:&quot;position&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type MoveTicketRequest struct {&#10;&#9;TicketID string `json:&quot;ticket_id&quot; binding:&quot;required&quot;`&#10;&#9;ColumnID string `json:&quot;column_id&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type MoveTicketWithPositionRequest struct {&#10;&#9;TicketID string `json:&quot;ticket_id&quot; binding:&quot;required&quot;`&#10;&#9;ColumnID string `json:&quot;column_id&quot; binding:&quot;required&quot;`&#10;&#9;Position int    `json:&quot;position&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;// Checklist DTOs&#10;type CreateChecklistRequest struct {&#10;&#9;TicketID string `json:&quot;ticket_id&quot; binding:&quot;required&quot;`&#10;&#9;Title    string `json:&quot;title&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type UpdateChecklistRequest struct {&#10;&#9;Title     *string `json:&quot;title&quot;`&#10;&#9;Completed *bool   `json:&quot;completed&quot;`&#10;&#9;Position  *int    `json:&quot;position&quot;`&#10;}&#10;&#10;type UpdateChecklistPositionRequest struct {&#10;&#9;Position int `json:&quot;position&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type ChecklistDTO struct {&#10;&#9;ID        string `json:&quot;id&quot;`&#10;&#9;TicketID  string `json:&quot;ticket_id&quot;`&#10;&#9;Title     string `json:&quot;title&quot;`&#10;&#9;Completed bool   `json:&quot;completed&quot;`&#10;&#9;Position  int    `json:&quot;position&quot;`&#10;&#9;CreatedAt string `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt string `json:&quot;updated_at&quot;`&#10;}&#10;&#10;// Response DTOs with assignments and checklists&#10;type TicketWithDetailsResponse struct {&#10;&#9;ID          string              `json:&quot;id&quot;`&#10;&#9;TicketNo    string              `json:&quot;ticket_no&quot;`&#10;&#9;ColumnID    string              `json:&quot;column_id&quot;`&#10;&#9;Title       string              `json:&quot;title&quot;`&#10;&#9;Description string              `json:&quot;description&quot;`&#10;&#9;DueDate     string              `json:&quot;due_date&quot;`&#10;&#9;Priority    string              `json:&quot;priority&quot;`&#10;&#9;Position    int                 `json:&quot;position&quot;`&#10;&#9;CreatedAt   string              `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   string              `json:&quot;updated_at&quot;`&#10;&#9;Assignments []AssignmentDTO     `json:&quot;assignments&quot;`&#10;&#9;Checklists  []ChecklistDTO      `json:&quot;checklists&quot;`&#10;}&#10;&#10;type AssignmentDTO struct {&#10;&#9;ID           string `json:&quot;id&quot;`&#10;&#9;TicketID     string `json:&quot;ticket_id&quot;`&#10;&#9;UserID       string `json:&quot;user_id&quot;`&#10;&#9;UserFullName string `json:&quot;user_full_name&quot;`&#10;&#9;AssignedAt   string `json:&quot;assigned_at&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/controller/ticket.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/controller/ticket.go" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/utils&quot;&#10;)&#10;&#10;// CreateTicket tạo ticket mới&#10;func (ctrl *Controller) CreateTicket(c *gin.Context) {&#10;&#9;var req CreateTicketRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Kiểm tra column có tồn tại không&#10;&#9;_, err := ctrl.Repository.GetColumnByID(req.ColumnID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Column not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Lấy position cuối cùng trong column&#10;&#9;maxPosition, err := ctrl.Repository.GetMaxTicketPositionInColumn(req.ColumnID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Tạo ticket number theo format TASK-XXXX&#10;&#9;ticketNo, err := ctrl.Repository.GenerateTicketNumber()&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;ticket := &amp;entity.Ticket{&#10;&#9;&#9;TicketNo:    ticketNo,&#10;&#9;&#9;ColumnID:    req.ColumnID,&#10;&#9;&#9;Title:       req.Title,&#10;&#9;&#9;Description: req.Description,&#10;&#9;&#9;DueDate:     req.DueDate,&#10;&#9;&#9;Priority:    req.Priority,&#10;&#9;&#9;Position:    maxPosition + 1, // Đặt ở cuối column&#10;&#9;&#9;CreatedAt:   time.Now().Format(time.RFC3339),&#10;&#9;&#9;UpdatedAt:   time.Now().Format(time.RFC3339),&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.CreateTicket(ticket); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Tạo assignments nếu có&#10;&#9;if req.Assignments != nil &amp;&amp; len(req.Assignments) &gt; 0 {&#10;&#9;&#9;for _, assignReq := range req.Assignments {&#10;&#9;&#9;&#9;assignment := &amp;entity.TaskAssignment{&#10;&#9;&#9;&#9;&#9;TicketID:     ticket.ID,&#10;&#9;&#9;&#9;&#9;UserID:       assignReq.UserID,&#10;&#9;&#9;&#9;&#9;UserFullName: assignReq.UserFullName,&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if err := ctrl.Repository.CreateAssignment(assignment); err != nil {&#10;&#9;&#9;&#9;&#9;// Log error but don't fail the whole operation&#10;&#9;&#9;&#9;&#9;fmt.Printf(&quot;Failed to create assignment: %v\n&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Tạo checklists nếu có&#10;&#9;if req.Checklists != nil &amp;&amp; len(req.Checklists) &gt; 0 {&#10;&#9;&#9;for i, checklistReq := range req.Checklists {&#10;&#9;&#9;&#9;checklist := &amp;entity.Checklist{&#10;&#9;&#9;&#9;&#9;TicketID:  ticket.ID,&#10;&#9;&#9;&#9;&#9;Title:     checklistReq.Title,&#10;&#9;&#9;&#9;&#9;Completed: false,&#10;&#9;&#9;&#9;&#9;Position:  i + 1,&#10;&#9;&#9;&#9;&#9;CreatedAt: time.Now().Format(time.RFC3339),&#10;&#9;&#9;&#9;&#9;UpdatedAt: time.Now().Format(time.RFC3339),&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if err := ctrl.Repository.CreateChecklist(checklist); err != nil {&#10;&#9;&#9;&#9;&#9;// Log error but don't fail the whole operation&#10;&#9;&#9;&#9;&#9;fmt.Printf(&quot;Failed to create checklist: %v\n&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Lấy ticket với assignments và checklists&#10;&#9;ticketWithDetails, err := ctrl.Repository.GetTicketWithDetails(ticket.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Ticket created successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    ticketWithDetails,&#10;&#9;})&#10;}&#10;&#10;// GetTickets lấy danh sách tickets&#10;func (ctrl *Controller) GetTickets(c *gin.Context) {&#10;&#9;columnID := c.Query(&quot;column_id&quot;)&#10;&#9;&#10;&#9;var tickets []entity.Ticket&#10;&#9;var err error&#10;&#10;&#9;if columnID != &quot;&quot; {&#10;&#9;&#9;tickets, err = ctrl.Repository.GetTicketsByColumnID(columnID)&#10;&#9;} else {&#10;&#9;&#9;tickets, err = ctrl.Repository.GetAllTickets()&#10;&#9;}&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Lấy tickets với assignments và checklists&#10;&#9;var ticketsWithDetails []interface{}&#10;&#9;for _, ticket := range tickets {&#10;&#9;&#9;ticketDetails, err := ctrl.Repository.GetTicketWithDetails(ticket.ID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// Log error but continue with other tickets&#10;&#9;&#9;&#9;fmt.Printf(&quot;Failed to get ticket details for %s: %v\n&quot;, ticket.ID, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;ticketsWithDetails = append(ticketsWithDetails, ticketDetails)&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;data&quot;: ticketsWithDetails,&#10;&#9;})&#10;}&#10;&#10;// GetTicketByID lấy ticket theo ID&#10;func (ctrl *Controller) GetTicketByID(c *gin.Context) {&#10;&#9;ticketID := c.Param(&quot;id&quot;)&#10;&#9;&#10;&#9;ticket, err := ctrl.Repository.GetTicketWithDetails(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Ticket not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;data&quot;: ticket,&#10;&#9;})&#10;}&#10;&#10;// UpdateTicket cập nhật ticket&#10;func (ctrl *Controller) UpdateTicket(c *gin.Context) {&#10;&#9;ticketID := c.Param(&quot;id&quot;)&#10;&#9;var req UpdateTicketRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;ticket, err := ctrl.Repository.GetTicketByID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Ticket not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Cập nhật các field nếu có trong request&#10;&#9;if req.Title != nil {&#10;&#9;&#9;ticket.Title = *req.Title&#10;&#9;}&#10;&#9;if req.Description != nil {&#10;&#9;&#9;ticket.Description = *req.Description&#10;&#9;}&#10;&#9;if req.DueDate != nil {&#10;&#9;&#9;ticket.DueDate = *req.DueDate&#10;&#9;}&#10;&#9;if req.Priority != nil {&#10;&#9;&#9;ticket.Priority = *req.Priority&#10;&#9;}&#10;&#10;&#9;ticket.UpdatedAt = time.Now().Format(time.RFC3339)&#10;&#10;&#9;if err := ctrl.Repository.UpdateTicket(ticket); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Xử lý assignments nếu có&#10;&#9;if req.Assignments != nil {&#10;&#9;&#9;// Xóa assignments cũ&#10;&#9;&#9;if err := ctrl.Repository.DeleteAssignmentsByTicketID(ticketID); err != nil {&#10;&#9;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Tạo assignments mới&#10;&#9;&#9;for _, assignReq := range req.Assignments {&#10;&#9;&#9;&#9;assignment := &amp;entity.TaskAssignment{&#10;&#9;&#9;&#9;&#9;TicketID:     ticketID,&#10;&#9;&#9;&#9;&#9;UserID:       assignReq.UserID,&#10;&#9;&#9;&#9;&#9;UserFullName: assignReq.UserFullName,&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if err := ctrl.Repository.CreateAssignment(assignment); err != nil {&#10;&#9;&#9;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Xử lý checklists nếu có&#10;&#9;if req.Checklists != nil {&#10;&#9;&#9;// Xóa checklists cũ&#10;&#9;&#9;if err := ctrl.Repository.DeleteChecklistsByTicketID(ticketID); err != nil {&#10;&#9;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Tạo checklists mới&#10;&#9;&#9;for i, checklistReq := range req.Checklists {&#10;&#9;&#9;&#9;checklist := &amp;entity.Checklist{&#10;&#9;&#9;&#9;&#9;TicketID:  ticketID,&#10;&#9;&#9;&#9;&#9;Title:     checklistReq.Title,&#10;&#9;&#9;&#9;&#9;Completed: checklistReq.Completed,&#10;&#9;&#9;&#9;&#9;Position:  i + 1,&#10;&#9;&#9;&#9;&#9;CreatedAt: time.Now().Format(time.RFC3339),&#10;&#9;&#9;&#9;&#9;UpdatedAt: time.Now().Format(time.RFC3339),&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if err := ctrl.Repository.CreateChecklist(checklist); err != nil {&#10;&#9;&#9;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Lấy ticket với details sau khi update&#10;&#9;ticketWithDetails, err := ctrl.Repository.GetTicketWithDetails(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Ticket updated successfully&quot;,&#10;&#9;&#9;&quot;data&quot;:    ticketWithDetails,&#10;&#9;})&#10;}&#10;&#10;// DeleteTicket xóa ticket&#10;func (ctrl *Controller) DeleteTicket(c *gin.Context) {&#10;&#9;ticketID := c.Param(&quot;id&quot;)&#10;&#10;&#9;if err := ctrl.Repository.DeleteTicket(ticketID); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Ticket deleted successfully&quot;,&#10;&#9;})&#10;}&#10;&#10;// UpdateTicketPosition cập nhật vị trí ticket trong column&#10;func (ctrl *Controller) UpdateTicketPosition(c *gin.Context) {&#10;&#9;ticketID := c.Param(&quot;id&quot;)&#10;&#9;var req UpdateTicketPositionRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.UpdateTicketPosition(ticketID, req.ColumnID, req.Position); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Ticket position updated successfully&quot;,&#10;&#9;})&#10;}&#10;&#10;// MoveTicketToColumn di chuyển ticket sang column khác&#10;func (ctrl *Controller) MoveTicketToColumn(c *gin.Context) {&#10;&#9;var req MoveTicketRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.MoveTicketToColumn(req.TicketID, req.ColumnID); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Ticket moved successfully&quot;,&#10;&#9;})&#10;}&#10;&#10;// MoveTicketWithPosition di chuyển ticket sang column khác với position cụ thể&#10;func (ctrl *Controller) MoveTicketWithPosition(c *gin.Context) {&#10;&#9;var req MoveTicketWithPositionRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;utils.JSON400(c, &quot;Invalid request body: &quot;+err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Kiểm tra ticket có tồn tại không&#10;&#9;_, err := ctrl.Repository.GetTicketByID(req.TicketID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Ticket not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Kiểm tra column có tồn tại không&#10;&#9;_, err = ctrl.Repository.GetColumnByID(req.ColumnID)&#10;&#9;if err != nil {&#10;&#9;&#9;utils.JSON404(c, &quot;Column not found&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := ctrl.Repository.MoveTicketToColumnWithPosition(req.TicketID, req.ColumnID, req.Position); err != nil {&#10;&#9;&#9;utils.JSON500(c, err.Error())&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;utils.JSON200(c, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;Ticket moved with position successfully&quot;,&#10;&#9;})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/entity/ticket.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/entity/ticket.go" />
              <option name="originalContent" value="package entity&#10;&#10;type Ticket struct {&#10;&#9;ID          string `gorm:&quot;primaryKey;type:uuid;default:gen_random_uuid()&quot; json:&quot;id&quot;`&#10;&#9;ColumnID    string `gorm:&quot;type:uuid;not null&quot; json:&quot;column_id&quot;`&#10;&#9;Title       string `gorm:&quot;type:text;not null&quot; json:&quot;title&quot;`&#10;&#9;Description string `gorm:&quot;type:text&quot; json:&quot;description&quot;`&#10;&#9;DueDate     string `gorm:&quot;type:date&quot; json:&quot;due_date&quot;`&#10;&#9;Priority    string `gorm:&quot;type:text&quot; json:&quot;priority&quot;`&#10;&#9;Position    int    `gorm:&quot;type:integer;default:0&quot; json:&quot;position&quot;`&#10;&#9;CreatedAt   string `gorm:&quot;type:timestamp with time zone;default:now()&quot; json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   string `gorm:&quot;type:timestamp with time zone;default:now()&quot; json:&quot;updated_at&quot;`&#10;}&#10;&#10;func (Ticket) TableName() string {&#10;&#9;return &quot;tickets&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package entity&#10;&#10;type Ticket struct {&#10;&#9;ID          string `gorm:&quot;primaryKey;type:uuid;default:gen_random_uuid()&quot; json:&quot;id&quot;`&#10;&#9;TicketNo    string `gorm:&quot;type:text;unique;not null&quot; json:&quot;ticket_no&quot;`&#10;&#9;ColumnID    string `gorm:&quot;type:uuid;not null&quot; json:&quot;column_id&quot;`&#10;&#9;Title       string `gorm:&quot;type:text;not null&quot; json:&quot;title&quot;`&#10;&#9;Description string `gorm:&quot;type:text&quot; json:&quot;description&quot;`&#10;&#9;DueDate     string `gorm:&quot;type:date&quot; json:&quot;due_date&quot;`&#10;&#9;Priority    string `gorm:&quot;type:text&quot; json:&quot;priority&quot;`&#10;&#9;Position    int    `gorm:&quot;type:integer;default:0&quot; json:&quot;position&quot;`&#10;&#9;CreatedAt   string `gorm:&quot;type:timestamp with time zone;default:now()&quot; json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   string `gorm:&quot;type:timestamp with time zone;default:now()&quot; json:&quot;updated_at&quot;`&#10;}&#10;&#10;func (Ticket) TableName() string {&#10;&#9;return &quot;tickets&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/000002_add_position_to_tickets.up.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/000002_add_position_to_tickets.up.sql" />
              <option name="updatedContent" value="ALTER TABLE tickets ADD COLUMN position INTEGER DEFAULT 0;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/000003_add_missing_tables.down.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/000003_add_missing_tables.down.sql" />
              <option name="updatedContent" value="-- Drop the tables and sequence created in the up migration&#10;&#10;DROP INDEX IF EXISTS idx_checklists_position;&#10;DROP INDEX IF EXISTS idx_checklists_ticket_id;&#10;DROP TABLE IF EXISTS checklists;&#10;&#10;DROP INDEX IF EXISTS idx_task_assignments_user_id;&#10;DROP INDEX IF EXISTS idx_task_assignments_ticket_id;&#10;DROP TABLE IF EXISTS task_assignments;&#10;&#10;DROP SEQUENCE IF EXISTS ticket_number_seq;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/000003_add_missing_tables.up.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/000003_add_missing_tables.up.sql" />
              <option name="updatedContent" value="-- Add missing tables and columns&#10;&#10;-- Create task_assignments table if not exists&#10;CREATE TABLE IF NOT EXISTS task_assignments (&#10;    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),&#10;    ticket_id UUID NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,&#10;    user_id UUID NOT NULL,&#10;    full_name TEXT NOT NULL,&#10;    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT now()&#10;);&#10;&#10;-- Create index for better performance&#10;CREATE INDEX IF NOT EXISTS idx_task_assignments_ticket_id ON task_assignments(ticket_id);&#10;CREATE INDEX IF NOT EXISTS idx_task_assignments_user_id ON task_assignments(user_id);&#10;&#10;-- Create checklists table if not exists&#10;CREATE TABLE IF NOT EXISTS checklists (&#10;    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),&#10;    ticket_id UUID NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,&#10;    title TEXT NOT NULL,&#10;    completed BOOLEAN DEFAULT false,&#10;    position INTEGER DEFAULT 0,&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),&#10;    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()&#10;);&#10;&#10;-- Create index for better performance&#10;CREATE INDEX IF NOT EXISTS idx_checklists_ticket_id ON checklists(ticket_id);&#10;CREATE INDEX IF NOT EXISTS idx_checklists_position ON checklists(ticket_id, position);&#10;&#10;-- Add sequence for ticket numbering if not exists&#10;CREATE SEQUENCE IF NOT EXISTS ticket_number_seq START 1;&#10;&#10;-- Update existing tickets to have proper ticket numbers if they don't have them&#10;UPDATE tickets &#10;SET ticket_no = 'TASK-' || LPAD(nextval('ticket_number_seq')::text, 4, '0')&#10;WHERE ticket_no IS NULL OR ticket_no = '';" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/000003_add_ticket_no.down.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/000003_add_ticket_no.down.sql" />
              <option name="updatedContent" value="ALTER TABLE tickets DROP COLUMN ticket_no;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/000005_add_checklists_table.up.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/000005_add_checklists_table.up.sql" />
              <option name="updatedContent" value="CREATE TABLE IF NOT EXISTS checklists (&#10;    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),&#10;    ticket_id UUID NOT NULL REFERENCES tickets(id) ON DELETE CASCADE,&#10;    title TEXT NOT NULL,&#10;    completed BOOLEAN DEFAULT FALSE,&#10;    position INTEGER DEFAULT 0,&#10;    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),&#10;    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()&#10;);&#10;&#10;CREATE INDEX IF NOT EXISTS idx_checklists_ticket_id ON checklists(ticket_id);&#10;CREATE INDEX IF NOT EXISTS idx_checklists_position ON checklists(ticket_id, position);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/20250808120000_empty_migration.down.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/20250808120000_empty_migration.down.sql" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrations/20250808120000_empty_migration.up.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrations/20250808120000_empty_migration.up.sql" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repository/checklist.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repository/checklist.go" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;)&#10;&#10;// Checklist methods&#10;&#10;func (r *Repository) CreateChecklist(checklist *entity.Checklist) error {&#10;&#9;return r.db.Create(checklist).Error&#10;}&#10;&#10;func (r *Repository) GetChecklistsByTicketID(ticketID string) ([]entity.Checklist, error) {&#10;&#9;var checklists []entity.Checklist&#10;&#9;err := r.db.Where(&quot;ticket_id = ?&quot;, ticketID).Order(&quot;position ASC&quot;).Find(&amp;checklists).Error&#10;&#9;return checklists, err&#10;}&#10;&#10;func (r *Repository) GetChecklistByID(id string) (*entity.Checklist, error) {&#10;&#9;var checklist entity.Checklist&#10;&#9;err := r.db.Where(&quot;id = ?&quot;, id).First(&amp;checklist).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;checklist, nil&#10;}&#10;&#10;func (r *Repository) UpdateChecklist(checklist *entity.Checklist) error {&#10;&#9;return r.db.Save(checklist).Error&#10;}&#10;&#10;func (r *Repository) DeleteChecklist(id string) error {&#10;&#9;return r.db.Where(&quot;id = ?&quot;, id).Delete(&amp;entity.Checklist{}).Error&#10;}&#10;&#10;func (r *Repository) DeleteChecklistsByTicketID(ticketID string) error {&#10;&#9;return r.db.Where(&quot;ticket_id = ?&quot;, ticketID).Delete(&amp;entity.Checklist{}).Error&#10;}&#10;&#10;func (r *Repository) UpdateChecklistPosition(id string, position int) error {&#10;&#9;return r.db.Model(&amp;entity.Checklist{}).Where(&quot;id = ?&quot;, id).Update(&quot;position&quot;, position).Error&#10;}&#10;&#10;func (r *Repository) GetMaxChecklistPosition(ticketID string) (int, error) {&#10;&#9;var maxPosition int&#10;&#9;err := r.db.Model(&amp;entity.Checklist{}).Where(&quot;ticket_id = ?&quot;, ticketID).Select(&quot;COALESCE(MAX(position), 0)&quot;).Scan(&amp;maxPosition).Error&#10;&#9;return maxPosition, err&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repository/checklist_repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repository/checklist_repository.go" />
              <option name="updatedContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;gau-kanban-service/entity&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type ChecklistRepository struct {&#10;&#9;DB *gorm.DB&#10;}&#10;&#10;func NewChecklistRepository(db *gorm.DB) *ChecklistRepository {&#10;&#9;return &amp;ChecklistRepository{&#10;&#9;&#9;DB: db,&#10;&#9;}&#10;}&#10;&#10;func (r *ChecklistRepository) Create(checklist *entity.Checklist) error {&#10;&#9;return r.DB.Create(checklist).Error&#10;}&#10;&#10;func (r *ChecklistRepository) GetByTicketID(ticketID string) ([]entity.Checklist, error) {&#10;&#9;var checklists []entity.Checklist&#10;&#9;err := r.DB.Where(&quot;ticket_id = ?&quot;, ticketID).Order(&quot;position ASC&quot;).Find(&amp;checklists).Error&#10;&#9;return checklists, err&#10;}&#10;&#10;func (r *ChecklistRepository) GetByID(id string) (*entity.Checklist, error) {&#10;&#9;var checklist entity.Checklist&#10;&#9;err := r.DB.Where(&quot;id = ?&quot;, id).First(&amp;checklist).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;checklist, nil&#10;}&#10;&#10;func (r *ChecklistRepository) Update(checklist *entity.Checklist) error {&#10;&#9;return r.DB.Save(checklist).Error&#10;}&#10;&#10;func (r *ChecklistRepository) Delete(id string) error {&#10;&#9;return r.DB.Where(&quot;id = ?&quot;, id).Delete(&amp;entity.Checklist{}).Error&#10;}&#10;&#10;func (r *ChecklistRepository) DeleteByTicketID(ticketID string) error {&#10;&#9;return r.DB.Where(&quot;ticket_id = ?&quot;, ticketID).Delete(&amp;entity.Checklist{}).Error&#10;}&#10;&#10;func (r *ChecklistRepository) UpdatePosition(id string, position int) error {&#10;&#9;return r.DB.Model(&amp;entity.Checklist{}).Where(&quot;id = ?&quot;, id).Update(&quot;position&quot;, position).Error&#10;}&#10;&#10;func (r *ChecklistRepository) GetMaxPosition(ticketID string) (int, error) {&#10;&#9;var maxPosition int&#10;&#9;err := r.DB.Model(&amp;entity.Checklist{}).Where(&quot;ticket_id = ?&quot;, ticketID).Select(&quot;COALESCE(MAX(position), 0)&quot;).Scan(&amp;maxPosition).Error&#10;&#9;return maxPosition, err&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repository/interfaces.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repository/interfaces.go" />
              <option name="updatedContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;)&#10;&#10;// ColumnRepositoryInterface defines methods for column operations&#10;type ColumnRepositoryInterface interface {&#10;&#9;Create(column *entity.Column) error&#10;&#9;GetAll() ([]entity.Column, error)&#10;&#9;GetByID(id string) (*entity.Column, error)&#10;&#9;Update(column *entity.Column) error&#10;&#9;Delete(id string) error&#10;&#9;UpdatePosition(id string, position int) error&#10;&#9;GetAllWithTickets() ([]ColumnWithTicketsDTO, error)&#10;&#9;GetAllWithFullTicketDetails() ([]ColumnWithTicketsDTO, error)&#10;}&#10;&#10;// TicketRepositoryInterface defines methods for ticket operations&#10;type TicketRepositoryInterface interface {&#10;&#9;CreateTicket(ticket *entity.Ticket) error&#10;&#9;GetAllTickets() ([]entity.Ticket, error)&#10;&#9;GetTicketByID(id string) (*entity.Ticket, error)&#10;&#9;GetTicketsByColumnID(columnID string) ([]entity.Ticket, error)&#10;&#9;UpdateTicket(ticket *entity.Ticket) error&#10;&#9;DeleteTicket(id string) error&#10;&#9;MoveTicketToColumn(ticketID, columnID string) error&#10;&#9;MoveTicketToColumnWithPosition(ticketID, columnID string, position int) error&#10;&#9;UpdateTicketPosition(ticketID, columnID string, position int) error&#10;&#9;GetMaxTicketPositionInColumn(columnID string) (int, error)&#10;&#9;GenerateTicketNumber() (string, error)&#10;&#9;GetTicketWithDetails(ticketID string) (*TicketWithDetailsResponse, error)&#10;}&#10;&#10;// TaskAssignmentRepositoryInterface defines methods for task assignment operations&#10;type TaskAssignmentRepositoryInterface interface {&#10;&#9;CreateAssignment(assignment *entity.TaskAssignment) error&#10;&#9;GetAllAssignments() ([]entity.TaskAssignment, error)&#10;&#9;GetAssignmentByID(id string) (*entity.TaskAssignment, error)&#10;&#9;GetAssignmentsByTicketID(ticketID string) ([]entity.TaskAssignment, error)&#10;&#9;GetAssignmentsByUserID(userID string) ([]entity.TaskAssignment, error)&#10;&#9;UpdateAssignment(assignment *entity.TaskAssignment) error&#10;&#9;DeleteAssignment(id string) error&#10;&#9;DeleteAssignmentsByTicketID(ticketID string) error&#10;&#9;DeleteAssignmentsByUserID(userID string) error&#10;}&#10;&#10;// ChecklistRepositoryInterface defines methods for checklist operations&#10;type ChecklistRepositoryInterface interface {&#10;&#9;CreateChecklist(checklist *entity.Checklist) error&#10;&#9;GetChecklistByID(id string) (*entity.Checklist, error)&#10;&#9;GetChecklistsByTicketID(ticketID string) ([]entity.Checklist, error)&#10;&#9;UpdateChecklist(checklist *entity.Checklist) error&#10;&#9;UpdateChecklistPosition(checklistID string, position int) error&#10;&#9;DeleteChecklist(id string) error&#10;&#9;DeleteChecklistsByTicketID(ticketID string) error&#10;&#9;GetMaxChecklistPosition(ticketID string) (int, error)&#10;}&#10;&#10;// LabelRepositoryInterface defines methods for label operations&#10;type LabelRepositoryInterface interface {&#10;&#9;Create(label *entity.Label) error&#10;&#9;GetAll() ([]entity.Label, error)&#10;&#9;GetByID(id string) (*entity.Label, error)&#10;&#9;Update(label *entity.Label) error&#10;&#9;Delete(id string) error&#10;&#9;GetByTicketID(ticketID string) ([]entity.Label, error)&#10;}&#10;&#10;// Repository interface combining all repository interfaces&#10;type RepositoryInterface interface {&#10;&#9;ColumnRepositoryInterface&#10;&#9;TicketRepositoryInterface&#10;&#9;TaskAssignmentRepositoryInterface&#10;&#9;ChecklistRepositoryInterface&#10;&#9;LabelRepositoryInterface&#10;}&#10;&#10;// Response DTOs&#10;type TicketWithDetailsResponse struct {&#10;&#9;ID          string        `json:&quot;id&quot;`&#10;&#9;TicketNo    string        `json:&quot;ticket_no&quot;`&#10;&#9;ColumnID    string        `json:&quot;column_id&quot;`&#10;&#9;Title       string        `json:&quot;title&quot;`&#10;&#9;Description string        `json:&quot;description&quot;`&#10;&#9;DueDate     string        `json:&quot;due_date&quot;`&#10;&#9;Priority    string        `json:&quot;priority&quot;`&#10;&#9;Position    int           `json:&quot;position&quot;`&#10;&#9;CreatedAt   string        `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   string        `json:&quot;updated_at&quot;`&#10;&#9;Assignments []AssignmentDTO `json:&quot;assignments&quot;`&#10;&#9;Checklists  []ChecklistDTO  `json:&quot;checklists&quot;`&#10;}&#10;&#10;type AssignmentDTO struct {&#10;&#9;ID           string `json:&quot;id&quot;`&#10;&#9;TicketID     string `json:&quot;ticket_id&quot;`&#10;&#9;UserID       string `json:&quot;user_id&quot;`&#10;&#9;UserFullName string `json:&quot;user_full_name&quot;`&#10;&#9;AssignedAt   string `json:&quot;assigned_at&quot;`&#10;}&#10;&#10;type ChecklistDTO struct {&#10;&#9;ID        string `json:&quot;id&quot;`&#10;&#9;TicketID  string `json:&quot;ticket_id&quot;`&#10;&#9;Title     string `json:&quot;title&quot;`&#10;&#9;Completed bool   `json:&quot;completed&quot;`&#10;&#9;Position  int    `json:&quot;position&quot;`&#10;&#9;CreatedAt string `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt string `json:&quot;updated_at&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repository/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repository/main.go" />
              <option name="originalContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/infra&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type Repository struct {&#10;&#9;db            *gorm.DB&#10;&#9;ChecklistRepo *ChecklistRepository&#10;&#9;//cacheDb        *redis.Client&#10;}&#10;&#10;var repository *Repository&#10;&#10;func InitRepository(infra *infra.Infra) *Repository {&#10;&#9;repository = &amp;Repository{&#10;&#9;&#9;db:            infra.Postgres.DB,&#10;&#9;&#9;ChecklistRepo: NewChecklistRepository(infra.Postgres.DB),&#10;&#9;&#9;//cacheDb: infra.Redis.Client,&#10;&#9;}&#10;&#9;if repository.db == nil {&#10;&#9;&#9;panic(&quot;database connection is nil&quot;)&#10;&#9;}&#10;&#9;return repository&#10;}&#10;&#10;func GetRepository() *Repository {&#10;&#9;if repository == nil {&#10;&#9;&#9;panic(&quot;repository not initialized&quot;)&#10;&#9;}&#10;&#9;return repository&#10;}&#10;" />
              <option name="updatedContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/infra&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type Repository struct {&#10;&#9;db *gorm.DB&#10;&#9;//cacheDb *redis.Client&#10;}&#10;&#10;var repository *Repository&#10;&#10;func InitRepository(infra *infra.Infra) *Repository {&#10;&#9;repository = &amp;Repository{&#10;&#9;&#9;db: infra.Postgres.DB,&#10;&#9;&#9;//cacheDb: infra.Redis.Client,&#10;&#9;}&#10;&#9;if repository.db == nil {&#10;&#9;&#9;panic(&quot;database connection is nil&quot;)&#10;&#9;}&#10;&#9;return repository&#10;}&#10;&#10;func GetRepository() *Repository {&#10;&#9;if repository == nil {&#10;&#9;&#9;panic(&quot;repository not initialized&quot;)&#10;&#9;}&#10;&#9;return repository&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repository/task_assignment.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repository/task_assignment.go" />
              <option name="originalContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;)&#10;&#10;func (r *Repository) CreateAssignment(assignment *entity.TaskAssignment) error {&#10;&#9;return r.db.Create(assignment).Error&#10;}&#10;&#10;func (r *Repository) GetAllAssignment() ([]entity.TaskAssignment, error) {&#10;&#9;var assignments []entity.TaskAssignment&#10;&#9;err := r.db.Order(&quot;assigned_at DESC&quot;).Find(&amp;assignments).Error&#10;&#9;return assignments, err&#10;}&#10;&#10;func (r *Repository) GetAssignmentByID(id string) (*entity.TaskAssignment, error) {&#10;&#9;var assignment entity.TaskAssignment&#10;&#9;err := r.db.Where(&quot;id = ?&quot;, id).First(&amp;assignment).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;assignment, nil&#10;}&#10;&#10;func (r *Repository) GetAssignmentByTicketID(ticketID string) ([]entity.TaskAssignment, error) {&#10;&#9;var assignments []entity.TaskAssignment&#10;&#9;err := r.db.Where(&quot;ticket_id = ?&quot;, ticketID).Order(&quot;assigned_at ASC&quot;).Find(&amp;assignments).Error&#10;&#9;return assignments, err&#10;}&#10;&#10;func (r *Repository) GetAssignmentsByTicketID(ticketID string) ([]entity.TaskAssignment, error) {&#10;&#9;return r.GetAssignmentByTicketID(ticketID)&#10;}&#10;&#10;func (r *Repository) GetAssignmentByUserID(userID string) ([]entity.TaskAssignment, error) {&#10;&#9;var assignments []entity.TaskAssignment&#10;&#9;err := r.db.Where(&quot;user_id = ?&quot;, userID).Order(&quot;assigned_at DESC&quot;).Find(&amp;assignments).Error&#10;&#9;return assignments, err&#10;}&#10;&#10;func (r *Repository) UpdateAssignment(assignment *entity.TaskAssignment) error {&#10;&#9;return r.db.Save(assignment).Error&#10;}&#10;&#10;func (r *Repository) DeleteAssignment(id string) error {&#10;&#9;return r.db.Delete(&amp;entity.TaskAssignment{}, &quot;id = ?&quot;, id).Error&#10;}&#10;&#10;func (r *Repository) DeleteAssignmentByTicketAndUser(ticketID, userID string) error {&#10;&#9;return r.db.Where(&quot;ticket_id = ? AND user_id = ?&quot;, ticketID, userID).Delete(&amp;entity.TaskAssignment{}).Error&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;)&#10;&#10;func (r *Repository) CreateAssignment(assignment *entity.TaskAssignment) error {&#10;&#9;return r.db.Create(assignment).Error&#10;}&#10;&#10;func (r *Repository) GetAllAssignments() ([]entity.TaskAssignment, error) {&#10;&#9;var assignments []entity.TaskAssignment&#10;&#9;err := r.db.Order(&quot;assigned_at DESC&quot;).Find(&amp;assignments).Error&#10;&#9;return assignments, err&#10;}&#10;&#10;func (r *Repository) GetAssignmentByID(id string) (*entity.TaskAssignment, error) {&#10;&#9;var assignment entity.TaskAssignment&#10;&#9;err := r.db.Where(&quot;id = ?&quot;, id).First(&amp;assignment).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;assignment, nil&#10;}&#10;&#10;func (r *Repository) GetAssignmentByTicketID(ticketID string) ([]entity.TaskAssignment, error) {&#10;&#9;var assignments []entity.TaskAssignment&#10;&#9;err := r.db.Where(&quot;ticket_id = ?&quot;, ticketID).Order(&quot;assigned_at ASC&quot;).Find(&amp;assignments).Error&#10;&#9;return assignments, err&#10;}&#10;&#10;func (r *Repository) GetAssignmentsByTicketID(ticketID string) ([]entity.TaskAssignment, error) {&#10;&#9;return r.GetAssignmentByTicketID(ticketID)&#10;}&#10;&#10;func (r *Repository) GetAssignmentByUserID(userID string) ([]entity.TaskAssignment, error) {&#10;&#9;var assignments []entity.TaskAssignment&#10;&#9;err := r.db.Where(&quot;user_id = ?&quot;, userID).Order(&quot;assigned_at DESC&quot;).Find(&amp;assignments).Error&#10;&#9;return assignments, err&#10;}&#10;&#10;func (r *Repository) UpdateAssignment(assignment *entity.TaskAssignment) error {&#10;&#9;return r.db.Save(assignment).Error&#10;}&#10;&#10;func (r *Repository) DeleteAssignment(id string) error {&#10;&#9;return r.db.Delete(&amp;entity.TaskAssignment{}, &quot;id = ?&quot;, id).Error&#10;}&#10;&#10;func (r *Repository) DeleteAssignmentsByTicketID(ticketID string) error {&#10;&#9;return r.db.Where(&quot;ticket_id = ?&quot;, ticketID).Delete(&amp;entity.TaskAssignment{}).Error&#10;}&#10;&#10;func (r *Repository) DeleteAssignmentsByUserID(userID string) error {&#10;&#9;return r.db.Where(&quot;user_id = ?&quot;, userID).Delete(&amp;entity.TaskAssignment{}).Error&#10;}&#10;&#10;func (r *Repository) DeleteAssignmentByTicketAndUser(ticketID, userID string) error {&#10;&#9;return r.db.Where(&quot;ticket_id = ? AND user_id = ?&quot;, ticketID, userID).Delete(&amp;entity.TaskAssignment{}).Error&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/repository/ticket.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/repository/ticket.go" />
              <option name="originalContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;)&#10;&#10;func (r *Repository) generateTicketNumber() (string, error) {&#10;&#9;var count int64&#10;&#9;err := r.db.Model(&amp;entity.Ticket{}).Count(&amp;count).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;TASK-%04d&quot;, count+1), nil&#10;}&#10;&#10;func (r *Repository) CreateTicket(ticket *entity.Ticket) error {&#10;&#9;// Generate ticket number nếu chưa có&#10;&#9;if ticket.TicketNo == &quot;&quot; {&#10;&#9;&#9;ticketNo, err := r.generateTicketNumber()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;&#9;ticket.TicketNo = ticketNo&#10;&#9;}&#10;&#10;&#9;// Nếu position chưa được set, đặt ticket ở cuối column&#10;&#9;if ticket.Position == 0 {&#10;&#9;&#9;maxPosition, err := r.getMaxPositionInColumn(ticket.ColumnID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;&#9;ticket.Position = maxPosition + 1&#10;&#9;}&#10;&#10;&#9;return r.db.Create(ticket).Error&#10;}&#10;&#10;// getMaxPositionInColumn lấy position cao nhất trong column&#10;func (r *Repository) getMaxPositionInColumn(columnID string) (int, error) {&#10;&#9;var maxPosition int&#10;&#9;err := r.db.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;Where(&quot;column_id = ?&quot;, columnID).&#10;&#9;&#9;Select(&quot;COALESCE(MAX(position), -1)&quot;).&#10;&#9;&#9;Scan(&amp;maxPosition).Error&#10;&#9;return maxPosition, err&#10;}&#10;&#10;func (r *Repository) GetAllTicket() ([]entity.Ticket, error) {&#10;&#9;var tickets []entity.Ticket&#10;&#9;err := r.db.Order(&quot;created_at DESC&quot;).Find(&amp;tickets).Error&#10;&#9;return tickets, err&#10;}&#10;&#10;func (r *Repository) GetTicketByID(id string) (*entity.Ticket, error) {&#10;&#9;var ticket entity.Ticket&#10;&#9;err := r.db.Where(&quot;id = ?&quot;, id).First(&amp;ticket).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;ticket, nil&#10;}&#10;&#10;func (r *Repository) GetTicketByColumnID(columnID string) ([]entity.Ticket, error) {&#10;&#9;var tickets []entity.Ticket&#10;&#9;err := r.db.Where(&quot;column_id = ?&quot;, columnID).Order(&quot;position ASC, created_at ASC&quot;).Find(&amp;tickets).Error&#10;&#9;return tickets, err&#10;}&#10;&#10;func (r *Repository) UpdateTicket(ticket *entity.Ticket) error {&#10;&#9;return r.db.Save(ticket).Error&#10;}&#10;&#10;func (r *Repository) DeleteTicket(id string) error {&#10;&#9;return r.db.Delete(&amp;entity.Ticket{}, &quot;id = ?&quot;, id).Error&#10;}&#10;&#10;func (r *Repository) MoveTicketToColumn(ticketID, columnID string) error {&#10;&#9;return r.db.Model(&amp;entity.Ticket{}).Where(&quot;id = ?&quot;, ticketID).Update(&quot;column_id&quot;, columnID).Error&#10;}&#10;&#10;// MoveTicketToColumnWithPosition di chuyển ticket sang column khác với position cụ thể&#10;func (r *Repository) MoveTicketToColumnWithPosition(ticketID, newColumnID string, newPosition int) error {&#10;&#9;// Lấy thông tin ticket hiện tại&#10;&#9;ticket, err := r.GetTicketByID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;oldColumnID := ticket.ColumnID&#10;&#9;oldPosition := ticket.Position&#10;&#10;&#9;// Bắt đầu transaction&#10;&#9;tx := r.db.Begin()&#10;&#9;if tx.Error != nil {&#10;&#9;&#9;return tx.Error&#10;&#9;}&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;if oldColumnID == newColumnID {&#10;&#9;&#9;// Nếu di chuyển trong cùng column, dùng logic UpdateTicketPosition&#10;&#9;&#9;if newPosition &lt; oldPosition {&#10;&#9;&#9;&#9;err = tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt;= ? AND position &lt; ? AND id != ?&quot;,&#10;&#9;&#9;&#9;&#9;&#9;newColumnID, newPosition, oldPosition, ticketID).&#10;&#9;&#9;&#9;&#9;Update(&quot;position&quot;, tx.Raw(&quot;position + 1&quot;)).Error&#10;&#9;&#9;} else if newPosition &gt; oldPosition {&#10;&#9;&#9;&#9;err = tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt; ? AND position &lt;= ? AND id != ?&quot;,&#10;&#9;&#9;&#9;&#9;&#9;newColumnID, oldPosition, newPosition, ticketID).&#10;&#9;&#9;&#9;&#9;Update(&quot;position&quot;, tx.Raw(&quot;position - 1&quot;)).Error&#10;&#9;&#9;}&#10;&#9;} else {&#10;&#9;&#9;// Di chuyển giữa các column khác nhau&#10;&#10;&#9;&#9;// 1. Cập nhật position trong column cũ (đóng khoảng trống)&#10;&#9;&#9;err = tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt; ?&quot;, oldColumnID, oldPosition).&#10;&#9;&#9;&#9;Update(&quot;position&quot;, tx.Raw(&quot;position - 1&quot;)).Error&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2. Cập nhật position trong column mới (tạo chỗ trống)&#10;&#9;&#9;err = tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt;= ?&quot;, newColumnID, newPosition).&#10;&#9;&#9;&#9;Update(&quot;position&quot;, tx.Raw(&quot;position + 1&quot;)).Error&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;tx.Rollback()&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Cập nhật ticket với column và position mới&#10;&#9;err = tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;Where(&quot;id = ?&quot;, ticketID).&#10;&#9;&#9;Updates(map[string]interface{}{&#10;&#9;&#9;&#9;&quot;column_id&quot;: newColumnID,&#10;&#9;&#9;&#9;&quot;position&quot;:  newPosition,&#10;&#9;&#9;}).Error&#10;&#9;if err != nil {&#10;&#9;&#9;tx.Rollback()&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return tx.Commit().Error&#10;}&#10;&#10;func (r *Repository) UpdateTicketPosition(ticketID string, newPosition int) error {&#10;&#9;// Lấy thông tin ticket hiện tại&#10;&#9;ticket, err := r.GetTicketByID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;oldPosition := ticket.Position&#10;&#9;columnID := ticket.ColumnID&#10;&#10;&#9;// Bắt đầu transaction&#10;&#9;tx := r.db.Begin()&#10;&#9;if tx.Error != nil {&#10;&#9;&#9;return tx.Error&#10;&#9;}&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// Nếu di chuyển lên (newPosition &lt; oldPosition)&#10;&#9;if newPosition &lt; oldPosition {&#10;&#9;&#9;// Các tickets có position từ newPosition đến oldPosition-1 sẽ tăng position lên 1&#10;&#9;&#9;err = tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt;= ? AND position &lt; ? AND id != ?&quot;,&#10;&#9;&#9;&#9;&#9;columnID, newPosition, oldPosition, ticketID).&#10;&#9;&#9;&#9;Update(&quot;position&quot;, tx.Raw(&quot;position + 1&quot;)).Error&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;} else if newPosition &gt; oldPosition {&#10;&#9;&#9;// Nếu di chuyển xuống (newPosition &gt; oldPosition)&#10;&#9;&#9;// Các tickets có position từ oldPosition+1 đến newPosition sẽ giảm position xuống 1&#10;&#9;&#9;err = tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt; ? AND position &lt;= ? AND id != ?&quot;,&#10;&#9;&#9;&#9;&#9;columnID, oldPosition, newPosition, ticketID).&#10;&#9;&#9;&#9;Update(&quot;position&quot;, tx.Raw(&quot;position - 1&quot;)).Error&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Cập nhật position của ticket được di chuyển&#10;&#9;err = tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;Where(&quot;id = ?&quot;, ticketID).&#10;&#9;&#9;Update(&quot;position&quot;, newPosition).Error&#10;&#9;if err != nil {&#10;&#9;&#9;tx.Rollback()&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return tx.Commit().Error&#10;}&#10;&#10;func (r *Repository) GetTicketWithAssignments(ticketID string) (*entity.Ticket, []entity.TaskAssignment, error) {&#10;&#9;var ticket entity.Ticket&#10;&#9;var assignments []entity.TaskAssignment&#10;&#10;&#9;err := r.db.Where(&quot;id = ?&quot;, ticketID).First(&amp;ticket).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, nil, err&#10;&#9;}&#10;&#10;&#9;err = r.db.Where(&quot;ticket_id = ?&quot;, ticketID).Find(&amp;assignments).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return &amp;ticket, nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;ticket, assignments, nil&#10;}&#10;&#10;func (r *Repository) GetTicketWithLabels(ticketID string) (*entity.Ticket, []entity.Label, error) {&#10;&#9;var ticket entity.Ticket&#10;&#9;var labels []entity.Label&#10;&#10;&#9;err := r.db.Where(&quot;id = ?&quot;, ticketID).First(&amp;ticket).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, nil, err&#10;&#9;}&#10;&#10;&#9;err = r.db.Table(&quot;labels&quot;).&#10;&#9;&#9;Joins(&quot;JOIN ticket_labels ON labels.id = ticket_labels.label_id&quot;).&#10;&#9;&#9;Where(&quot;ticket_labels.ticket_id = ?&quot;, ticketID).&#10;&#9;&#9;Find(&amp;labels).Error&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;return &amp;ticket, nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;ticket, labels, nil&#10;}&#10;&#10;func (r *Repository) SearchTicket(query string) ([]entity.Ticket, error) {&#10;&#9;var tickets []entity.Ticket&#10;&#9;searchPattern := &quot;%&quot; + query + &quot;%&quot;&#10;&#9;err := r.db.Where(&quot;title ILIKE ? OR description ILIKE ?&quot;, searchPattern, searchPattern).&#10;&#9;&#9;Order(&quot;created_at DESC&quot;).Find(&amp;tickets).Error&#10;&#9;return tickets, err&#10;}&#10;&#10;func (r *Repository) GetTicketDetail(ticketID string) (*TicketDetailDTO, error) {&#10;&#9;var ticket entity.Ticket&#10;&#9;var column entity.Column&#10;&#10;&#9;// Lấy thông tin ticket&#10;&#9;err := r.db.Where(&quot;id = ?&quot;, ticketID).First(&amp;ticket).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Lấy thông tin column&#10;&#9;err = r.db.Where(&quot;id = ?&quot;, ticket.ColumnID).First(&amp;column).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Lấy labels chi tiết&#10;&#9;var labels []LabelDTO&#10;&#9;err = r.db.Table(&quot;labels&quot;).&#10;&#9;&#9;Select(&quot;labels.id, labels.name, labels.color&quot;).&#10;&#9;&#9;Joins(&quot;JOIN ticket_labels ON labels.id = ticket_labels.label_id&quot;).&#10;&#9;&#9;Where(&quot;ticket_labels.ticket_id = ?&quot;, ticket.ID).&#10;&#9;&#9;Scan(&amp;labels).Error&#10;&#9;if err != nil {&#10;&#9;&#9;labels = []LabelDTO{}&#10;&#9;}&#10;&#10;&#9;// Lấy assignees chi tiết&#10;&#9;var assignees []AssigneeDTO&#10;&#9;err = r.db.Table(&quot;task_assignments&quot;).&#10;&#9;&#9;Select(&quot;task_assignments.id, task_assignments.user_id, task_assignments.user_full_name as user_full_name, task_assignments.assigned_at&quot;).&#10;&#9;&#9;Where(&quot;ticket_id = ?&quot;, ticket.ID).&#10;&#9;&#9;Scan(&amp;assignees).Error&#10;&#9;if err != nil {&#10;&#9;&#9;assignees = []AssigneeDTO{}&#10;&#9;}&#10;&#10;&#9;// Lấy comments chi tiết&#10;&#9;var comments []CommentDTO&#10;&#9;err = r.db.Table(&quot;ticket_comments&quot;).&#10;&#9;&#9;Select(&quot;id, user_id, content, created_at&quot;).&#10;&#9;&#9;Where(&quot;ticket_id = ?&quot;, ticket.ID).&#10;&#9;&#9;Order(&quot;created_at ASC&quot;).&#10;&#9;&#9;Scan(&amp;comments).Error&#10;&#9;if err != nil {&#10;&#9;&#9;comments = []CommentDTO{}&#10;&#9;}&#10;&#10;&#9;// Xác định completed&#10;&#9;completed := column.Name == &quot;DONE&quot; || column.Name == &quot;COMPLETED&quot;&#10;&#10;&#9;ticketDTO := TicketDTO{&#10;&#9;&#9;ID:          ticket.ID,&#10;&#9;&#9;Title:       ticket.Title,&#10;&#9;&#9;Description: ticket.Description,&#10;&#9;&#9;TicketID:    ticket.ID,&#10;&#9;&#9;Labels:      labels,&#10;&#9;&#9;Assignees:   assignees,&#10;&#9;&#9;Comments:    comments,&#10;&#9;&#9;Completed:   completed,&#10;&#9;&#9;DueDate:     ticket.DueDate,&#10;&#9;&#9;Priority:    ticket.Priority,&#10;&#9;&#9;CreatedAt:   ticket.CreatedAt,&#10;&#9;&#9;UpdatedAt:   ticket.UpdatedAt,&#10;&#9;}&#10;&#10;&#9;columnDTO := ColumnDTO{&#10;&#9;&#9;ID:        column.ID,&#10;&#9;&#9;Name:      column.Name,&#10;&#9;&#9;Position:  column.Position,&#10;&#9;&#9;CreatedAt: column.CreatedAt,&#10;&#9;&#9;UpdatedAt: column.UpdatedAt,&#10;&#9;}&#10;&#10;&#9;result := &amp;TicketDetailDTO{&#10;&#9;&#9;Ticket:    ticketDTO,&#10;&#9;&#9;Column:    columnDTO,&#10;&#9;&#9;Labels:    labels,&#10;&#9;&#9;Assignees: assignees,&#10;&#9;&#9;Comments:  comments,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;&#10;func (r *Repository) GetTicketWithAllRelations(ticketID string) (*TicketDTO, error) {&#10;&#9;var ticket entity.Ticket&#10;&#9;var column entity.Column&#10;&#10;&#9;// Lấy thông tin ticket&#10;&#9;err := r.db.Where(&quot;id = ?&quot;, ticketID).First(&amp;ticket).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Lấy thông tin column để xác định completed&#10;&#9;err = r.db.Where(&quot;id = ?&quot;, ticket.ColumnID).First(&amp;column).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Lấy labels chi tiết&#10;&#9;var labels []LabelDTO&#10;&#9;err = r.db.Table(&quot;labels&quot;).&#10;&#9;&#9;Select(&quot;labels.id, labels.name, labels.color&quot;).&#10;&#9;&#9;Joins(&quot;JOIN ticket_labels ON labels.id = ticket_labels.label_id&quot;).&#10;&#9;&#9;Where(&quot;ticket_labels.ticket_id = ?&quot;, ticket.ID).&#10;&#9;&#9;Scan(&amp;labels).Error&#10;&#9;if err != nil {&#10;&#9;&#9;labels = []LabelDTO{}&#10;&#9;}&#10;&#10;&#9;// Lấy assignees chi tiết&#10;&#9;var assignees []AssigneeDTO&#10;&#9;err = r.db.Table(&quot;task_assignments&quot;).&#10;&#9;&#9;Select(&quot;task_assignments.id, task_assignments.user_id, task_assignments.user_full_name as user_full_name, task_assignments.assigned_at&quot;).&#10;&#9;&#9;Where(&quot;ticket_id = ?&quot;, ticket.ID).&#10;&#9;&#9;Scan(&amp;assignees).Error&#10;&#9;if err != nil {&#10;&#9;&#9;assignees = []AssigneeDTO{}&#10;&#9;}&#10;&#10;&#9;// Lấy comments chi tiết&#10;&#9;var comments []CommentDTO&#10;&#9;err = r.db.Table(&quot;ticket_comments&quot;).&#10;&#9;&#9;Select(&quot;id, user_id, content, created_at&quot;).&#10;&#9;&#9;Where(&quot;ticket_id = ?&quot;, ticket.ID).&#10;&#9;&#9;Order(&quot;created_at ASC&quot;).&#10;&#9;&#9;Scan(&amp;comments).Error&#10;&#9;if err != nil {&#10;&#9;&#9;comments = []CommentDTO{}&#10;&#9;}&#10;&#10;&#9;// Xác định completed&#10;&#9;completed := column.Name == &quot;DONE&quot; || column.Name == &quot;COMPLETED&quot;&#10;&#10;&#9;result := &amp;TicketDTO{&#10;&#9;&#9;ID:          ticket.ID,&#10;&#9;&#9;Title:       ticket.Title,&#10;&#9;&#9;Description: ticket.Description,&#10;&#9;&#9;TicketID:    ticket.ID,&#10;&#9;&#9;Labels:      labels,&#10;&#9;&#9;Assignees:   assignees,&#10;&#9;&#9;Comments:    comments,&#10;&#9;&#9;Completed:   completed,&#10;&#9;&#9;DueDate:     ticket.DueDate,&#10;&#9;&#9;Priority:    ticket.Priority,&#10;&#9;&#9;CreatedAt:   ticket.CreatedAt,&#10;&#9;&#9;UpdatedAt:   ticket.UpdatedAt,&#10;&#9;}&#10;&#10;&#9;return result, nil&#10;}&#10;" />
              <option name="updatedContent" value="package repository&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/entity&quot;&#10;)&#10;&#10;// GenerateTicketNumber tạo ticket number theo format TASK-XXXX&#10;func (r *Repository) GenerateTicketNumber() (string, error) {&#10;&#9;var nextVal int&#10;&#9;err := r.db.Raw(&quot;SELECT nextval('ticket_number_seq')&quot;).Scan(&amp;nextVal).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, err&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;TASK-%04d&quot;, nextVal), nil&#10;}&#10;&#10;func (r *Repository) CreateTicket(ticket *entity.Ticket) error {&#10;&#9;// Generate ticket number nếu chưa có&#10;&#9;if ticket.TicketNo == &quot;&quot; {&#10;&#9;&#9;ticketNo, err := r.GenerateTicketNumber()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;&#9;ticket.TicketNo = ticketNo&#10;&#9;}&#10;&#10;&#9;// Nếu position chưa được set, đặt ticket ở cuối column&#10;&#9;if ticket.Position == 0 {&#10;&#9;&#9;maxPosition, err := r.GetMaxTicketPositionInColumn(ticket.ColumnID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;&#9;ticket.Position = maxPosition + 1&#10;&#9;}&#10;&#10;&#9;return r.db.Create(ticket).Error&#10;}&#10;&#10;// GetMaxTicketPositionInColumn lấy position cao nhất trong column&#10;func (r *Repository) GetMaxTicketPositionInColumn(columnID string) (int, error) {&#10;&#9;var maxPosition int&#10;&#9;err := r.db.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;Where(&quot;column_id = ?&quot;, columnID).&#10;&#9;&#9;Select(&quot;COALESCE(MAX(position), 0)&quot;).&#10;&#9;&#9;Scan(&amp;maxPosition).Error&#10;&#9;return maxPosition, err&#10;}&#10;&#10;func (r *Repository) GetAllTickets() ([]entity.Ticket, error) {&#10;&#9;var tickets []entity.Ticket&#10;&#9;err := r.db.Order(&quot;position ASC, created_at DESC&quot;).Find(&amp;tickets).Error&#10;&#9;return tickets, err&#10;}&#10;&#10;func (r *Repository) GetTicketsByColumnID(columnID string) ([]entity.Ticket, error) {&#10;&#9;var tickets []entity.Ticket&#10;&#9;err := r.db.Where(&quot;column_id = ?&quot;, columnID).&#10;&#9;&#9;Order(&quot;position ASC, created_at DESC&quot;).&#10;&#9;&#9;Find(&amp;tickets).Error&#10;&#9;return tickets, err&#10;}&#10;&#10;func (r *Repository) GetTicketByID(id string) (*entity.Ticket, error) {&#10;&#9;var ticket entity.Ticket&#10;&#9;err := r.db.First(&amp;ticket, &quot;id = ?&quot;, id).Error&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return &amp;ticket, nil&#10;}&#10;&#10;func (r *Repository) UpdateTicket(ticket *entity.Ticket) error {&#10;&#9;return r.db.Save(ticket).Error&#10;}&#10;&#10;func (r *Repository) DeleteTicket(id string) error {&#10;&#9;// Xóa các assignments và checklists liên quan trước&#10;&#9;if err := r.DeleteAssignmentsByTicketID(id); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;if err := r.DeleteChecklistsByTicketID(id); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;&#10;&#9;return r.db.Delete(&amp;entity.Ticket{}, &quot;id = ?&quot;, id).Error&#10;}&#10;&#10;// UpdateTicketPosition cập nhật vị trí ticket trong column&#10;func (r *Repository) UpdateTicketPosition(ticketID, columnID string, newPosition int) error {&#10;&#9;tx := r.db.Begin()&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// Lấy ticket hiện tại&#10;&#9;var currentTicket entity.Ticket&#10;&#9;if err := tx.First(&amp;currentTicket, &quot;id = ?&quot;, ticketID).Error; err != nil {&#10;&#9;&#9;tx.Rollback()&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;oldPosition := currentTicket.Position&#10;&#9;oldColumnID := currentTicket.ColumnID&#10;&#10;&#9;// Nếu di chuyển trong cùng column&#10;&#9;if oldColumnID == columnID {&#10;&#9;&#9;if oldPosition == newPosition {&#10;&#9;&#9;&#9;tx.Commit()&#10;&#9;&#9;&#9;return nil // Không có thay đổi&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if oldPosition &lt; newPosition {&#10;&#9;&#9;&#9;// Di chuyển xuống: giảm position của các ticket từ oldPosition+1 đến newPosition&#10;&#9;&#9;&#9;if err := tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt; ? AND position &lt;= ?&quot;, columnID, oldPosition, newPosition).&#10;&#9;&#9;&#9;&#9;Update(&quot;position&quot;, r.db.Raw(&quot;position - 1&quot;)).Error; err != nil {&#10;&#9;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;// Di chuyển lên: tăng position của các ticket từ newPosition đến oldPosition-1&#10;&#9;&#9;&#9;if err := tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt;= ? AND position &lt; ?&quot;, columnID, newPosition, oldPosition).&#10;&#9;&#9;&#9;&#9;Update(&quot;position&quot;, r.db.Raw(&quot;position + 1&quot;)).Error; err != nil {&#10;&#9;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;} else {&#10;&#9;&#9;// Di chuyển sang column khác&#10;&#9;&#9;// Giảm position của các ticket sau vị trí cũ trong column cũ&#10;&#9;&#9;if err := tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt; ?&quot;, oldColumnID, oldPosition).&#10;&#9;&#9;&#9;Update(&quot;position&quot;, r.db.Raw(&quot;position - 1&quot;)).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Tăng position của các ticket từ newPosition trở đi trong column mới&#10;&#9;&#9;if err := tx.Model(&amp;entity.Ticket{}).&#10;&#9;&#9;&#9;Where(&quot;column_id = ? AND position &gt;= ?&quot;, columnID, newPosition).&#10;&#9;&#9;&#9;Update(&quot;position&quot;, r.db.Raw(&quot;position + 1&quot;)).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Cập nhật ticket hiện tại&#10;&#9;if err := tx.Model(&amp;currentTicket).Updates(map[string]interface{}{&#10;&#9;&#9;&quot;column_id&quot;: columnID,&#10;&#9;&#9;&quot;position&quot;:  newPosition,&#10;&#9;}).Error; err != nil {&#10;&#9;&#9;tx.Rollback()&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return tx.Commit().Error&#10;}&#10;&#10;// MoveTicketToColumn di chuyển ticket sang column khác (đặt ở cuối)&#10;func (r *Repository) MoveTicketToColumn(ticketID, columnID string) error {&#10;&#9;maxPosition, err := r.GetMaxTicketPositionInColumn(columnID)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;return r.UpdateTicketPosition(ticketID, columnID, maxPosition+1)&#10;}&#10;&#10;// MoveTicketToColumnWithPosition di chuyển ticket sang column khác với position cụ thể&#10;func (r *Repository) MoveTicketToColumnWithPosition(ticketID, columnID string, position int) error {&#10;&#9;return r.UpdateTicketPosition(ticketID, columnID, position)&#10;}&#10;&#10;// GetTicketWithDetails lấy ticket kèm assignments và checklists&#10;func (r *Repository) GetTicketWithDetails(ticketID string) (*TicketWithDetailsResponse, error) {&#10;&#9;// Lấy ticket&#10;&#9;ticket, err := r.GetTicketByID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Lấy assignments&#10;&#9;assignments, err := r.GetAssignmentsByTicketID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Lấy checklists&#10;&#9;checklists, err := r.GetChecklistsByTicketID(ticketID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Chuyển đổi sang DTOs&#10;&#9;var assignmentDTOs []AssignmentDTO&#10;&#9;for _, assignment := range assignments {&#10;&#9;&#9;assignmentDTOs = append(assignmentDTOs, AssignmentDTO{&#10;&#9;&#9;&#9;ID:           assignment.ID,&#10;&#9;&#9;&#9;TicketID:     assignment.TicketID,&#10;&#9;&#9;&#9;UserID:       assignment.UserID,&#10;&#9;&#9;&#9;UserFullName: assignment.UserFullName,&#10;&#9;&#9;&#9;AssignedAt:   assignment.AssignedAt,&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;var checklistDTOs []ChecklistDTO&#10;&#9;for _, checklist := range checklists {&#10;&#9;&#9;checklistDTOs = append(checklistDTOs, ChecklistDTO{&#10;&#9;&#9;&#9;ID:        checklist.ID,&#10;&#9;&#9;&#9;TicketID:  checklist.TicketID,&#10;&#9;&#9;&#9;Title:     checklist.Title,&#10;&#9;&#9;&#9;Completed: checklist.Completed,&#10;&#9;&#9;&#9;Position:  checklist.Position,&#10;&#9;&#9;&#9;CreatedAt: checklist.CreatedAt,&#10;&#9;&#9;&#9;UpdatedAt: checklist.UpdatedAt,&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;response := &amp;TicketWithDetailsResponse{&#10;&#9;&#9;ID:          ticket.ID,&#10;&#9;&#9;TicketNo:    ticket.TicketNo,&#10;&#9;&#9;ColumnID:    ticket.ColumnID,&#10;&#9;&#9;Title:       ticket.Title,&#10;&#9;&#9;Description: ticket.Description,&#10;&#9;&#9;DueDate:     ticket.DueDate,&#10;&#9;&#9;Priority:    ticket.Priority,&#10;&#9;&#9;Position:    ticket.Position,&#10;&#9;&#9;CreatedAt:   ticket.CreatedAt,&#10;&#9;&#9;UpdatedAt:   ticket.UpdatedAt,&#10;&#9;&#9;Assignments: assignmentDTOs,&#10;&#9;&#9;Checklists:  checklistDTOs,&#10;&#9;}&#10;&#10;&#9;return response, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/routes/routes.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/routes/routes.go" />
              <option name="updatedContent" value="package routes&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/tnqbao/gau-kanban-service/controller&quot;&#10;)&#10;&#10;func SetupRoutes(r *gin.Engine, ctrl *controller.Controller) {&#10;&#9;api := r.Group(&quot;/api&quot;)&#10;&#9;{&#10;&#9;&#9;// Column routes&#10;&#9;&#9;columns := api.Group(&quot;/columns&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;columns.POST(&quot;&quot;, ctrl.CreateColumn)&#10;&#9;&#9;&#9;columns.GET(&quot;&quot;, ctrl.GetColumns)&#10;&#9;&#9;&#9;columns.GET(&quot;/:id&quot;, ctrl.GetColumnByID)&#10;&#9;&#9;&#9;columns.PUT(&quot;/:id&quot;, ctrl.UpdateColumn)&#10;&#9;&#9;&#9;columns.DELETE(&quot;/:id&quot;, ctrl.DeleteColumn)&#10;&#9;&#9;&#9;columns.PUT(&quot;/:id/position&quot;, ctrl.UpdateColumnPosition)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Ticket routes&#10;&#9;&#9;tickets := api.Group(&quot;/tickets&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;tickets.POST(&quot;&quot;, ctrl.CreateTicket)&#10;&#9;&#9;&#9;tickets.GET(&quot;&quot;, ctrl.GetTickets)&#10;&#9;&#9;&#9;tickets.GET(&quot;/:id&quot;, ctrl.GetTicketByID)&#10;&#9;&#9;&#9;tickets.PUT(&quot;/:id&quot;, ctrl.UpdateTicket)&#10;&#9;&#9;&#9;tickets.DELETE(&quot;/:id&quot;, ctrl.DeleteTicket)&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;// Position and movement operations&#10;&#9;&#9;&#9;tickets.PUT(&quot;/:id/position&quot;, ctrl.UpdateTicketPosition)&#10;&#9;&#9;&#9;tickets.PUT(&quot;/move&quot;, ctrl.MoveTicketToColumn)&#10;&#9;&#9;&#9;tickets.PUT(&quot;/move-with-position&quot;, ctrl.MoveTicketWithPosition)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Assignment routes&#10;&#9;&#9;assignments := api.Group(&quot;/assignments&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;assignments.POST(&quot;&quot;, ctrl.CreateAssignment)&#10;&#9;&#9;&#9;assignments.GET(&quot;/ticket/:ticket_id&quot;, ctrl.GetTicketAssignments)&#10;&#9;&#9;&#9;assignments.PUT(&quot;/:id&quot;, ctrl.UpdateAssignment)&#10;&#9;&#9;&#9;assignments.DELETE(&quot;/:id&quot;, ctrl.DeleteAssignment)&#10;&#9;&#9;&#9;assignments.DELETE(&quot;/user/:user_id&quot;, ctrl.DeleteAssignmentsByUserID)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Checklist routes&#10;&#9;&#9;checklists := api.Group(&quot;/checklists&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;checklists.POST(&quot;&quot;, ctrl.CreateChecklist)&#10;&#9;&#9;&#9;checklists.GET(&quot;/ticket/:ticketId&quot;, ctrl.GetChecklistsByTicketID)&#10;&#9;&#9;&#9;checklists.PUT(&quot;/:id&quot;, ctrl.UpdateChecklist)&#10;&#9;&#9;&#9;checklists.PUT(&quot;/:id/position&quot;, ctrl.UpdateChecklistPosition)&#10;&#9;&#9;&#9;checklists.DELETE(&quot;/:id&quot;, ctrl.DeleteChecklist)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Kanban board view routes&#10;&#9;&#9;kanban := api.Group(&quot;/kanban&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;kanban.GET(&quot;/board&quot;, ctrl.GetKanbanBoard)&#10;&#9;&#9;}&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>